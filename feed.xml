<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://alexmas.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://alexmas.github.io//" rel="alternate" type="text/html" hreflang="ru"/><updated>2025-12-14T17:17:43+00:00</updated><id>https://alexmas.github.io//feed.xml</id><title type="html">blank</title><subtitle>Персональный сайт Александра Межова. </subtitle><entry><title type="html">9 архитектурных заблуждений о распределённых системах</title><link href="https://alexmas.github.io//blog/2025/9-fallacies-distributed-computing/" rel="alternate" type="text/html" title="9 архитектурных заблуждений о распределённых системах"/><published>2025-12-12T00:00:00+00:00</published><updated>2025-12-12T00:00:00+00:00</updated><id>https://alexmas.github.io//blog/2025/9-fallacies-distributed-computing</id><content type="html" xml:base="https://alexmas.github.io//blog/2025/9-fallacies-distributed-computing/"><![CDATA[<p>По сути, каждый, кто впервые создаёт распределённое приложение, делает следующие 8 предположений. Все они в конечном итоге оказываются ложными и все приводят к <em>большим</em> проблемам и <em>болезненному</em> опыту.</p> <p><img src="/assets/img/blog/2025/2025-12-12-9-fallacies-distributed-computing.jpg" alt=""/></p> <p>Это цитата, а сами <a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">заблуждения</a> сформулированы более 30 лет назад (1991-1997) и до сих пор актуальны. Авторство приписывают Peter Deutsch и некоторым инженерам из Sun Microsystems.</p> <ol> <li> <p><em>The network is reliable / Сеть надёжна.</em> Думаем о том, как будет совершаться вызов или доставляться сообщение. Обеспечение надёжности передачи можно возложить на внешние механизмы (инфраструктуру, очереди, оркестраторы, outbox и т.п.); и/или самостоятельную реализацию (retries, dead letter, deadline propagation, circuit breakers и т.п.). На этом же уровне думаем о возможной многократной доставке, порядке и идемпотентности обработки.</p> </li> <li> <p><em>Latency is zero / Нулевая задержка.</em> Думаем, в какой сети происходит взаимодействие: в локальной или глобальной (через горы-моря-океаны). Задержка более проблематична, чем пропускная способность, ведь есть физические ограничения по скорости передачи. Соответственно, стараемся минимизировать количество сетевых взаимодействий; размер передаваемых данных; оптимизируем маршруты, необходимые для выполнения каждого сценария; вспоминаем про кэширование, пакетную обработку и <a href="/blog/2024/data-flow-speeding-up/">локальность вычислений</a>.</p> </li> <li> <p><em>Bandwidth is infinite / Неограниченная пропускная способность.</em> Пропускная способность растет, но растут и наши потребности. Вопрос лишь в том, насколько они адекватны. Насколько адекватно, когда сервис возвращает модель из множества атрибутов, но из всех нужен только один? Умножаем размер одного такого сообщения на их количество в секунду и сравниваем полученный результат с пропускной способностью используемой сети, принимая во внимание возможные сетевые потери. Только на оптимизации трафика можно существенно сэкономить и улучшить показатели. Тут можно вспомнить и про бинарные форматы (Avro, Protobuf, MessagePack).</p> </li> <li> <p><em>The network is secure / Сеть безопасна.</em> С одной стороны, уровень безопасности должен соответствовать уровню возможных угроз. С другой, для атаки всегда пытаются найти самое слабое звено. Поэтому в идеале защита не только по внешнему периметру, но и внутри. Как минимум, стоит задуматься об аутентификации/авторизации запросов, разделении аккаунтов доступа к используемым ресурсам (БД и т.п.). Для себя я нашел очень хорошую шпаргалку по этой теме — <a href="https://cheatsheetseries.owasp.org/">OWASP Cheat Sheet Series</a>.</p> </li> <li> <p><em>Topology doesn’t change / Топология не меняется.</em> После развертывания приложение уже не под вашим контролем. Считаем, что приложение развертывается в дикой и враждебной среде, где узлы появляются и исчезают в случайные моменты времени. Никогда не полагаемся на конкретные маршруты, узлы и IP-адреса; всё должно быть адаптивно. Изменение топологии не должно заставлять менять приложение.</p> </li> <li> <p><em>There is one administrator / Администратор всегда один.</em> Проблема проявляется сильней, если есть отдельная операционная команда или даже отдельная организация, которая выполняет эту роль. Налаживаем коммуникации, автоматизируем развертывание, добавляем средства диагностики и инструкции использования. Всё это работает в обе стороны: упрощаете жизнь операционной команде — упрощаете жизнь себе.</p> </li> <li> <p><em>Transport cost is zero / Передача данных бесплатна.</em> Сериализация/десериализация — это затраты на память и CPU; возможность передачи по сети — это затраты на оборудование и его обслуживание. Здесь архитектор и разработчик должны еще раз вернуться к заблуждениям 2 и 3.</p> </li> <li> <p><em>The network is homogeneous / Сеть однородна.</em> Даже в локальной сети однородность — редкое достижение. Разные производители и ресурсы, ОС и приложения, разные версии API и т.д. Выжить в этом безумном мире помогает стандартизация и обратная совместимость.</p> </li> </ol> <p>И 9-е бонусное заблуждение лично от меня:</p> <p><strong>9.</strong> <em>Контейнеры бесплатны.</em> Не хватает производительности — докинем еще несколько экземпляров! Выглядит разумно для “тушения пожаров”, но не в долгосрочной перспективе. Оптимизация кода или пересмотр решения — улучшают производительность; масштабирование — позволяет справиться с нагрузкой!</p> <hr/> <p>Думаю, что каждый увидел себя в каждом эпизоде! Но кто без греха?! Всем поменьше заблуждений!</p>]]></content><author><name></name></author><category term="post"/><category term="arch"/><summary type="html"><![CDATA[По сути, каждый, кто впервые создаёт распределённое приложение, делает следующие 8 предположений. Все они в конечном итоге оказываются ложными и все приводят к большим проблемам и болезненному опыту.]]></summary></entry><entry><title type="html">Порочные связи между компонентами</title><link href="https://alexmas.github.io//blog/2025/connascence/" rel="alternate" type="text/html" title="Порочные связи между компонентами"/><published>2025-12-03T00:00:00+00:00</published><updated>2025-12-03T00:00:00+00:00</updated><id>https://alexmas.github.io//blog/2025/connascence</id><content type="html" xml:base="https://alexmas.github.io//blog/2025/connascence/"><![CDATA[<p>Думаю, многие пытались оценивать качество своей архитектуры, анализируя входящие и исходящие связи между элементами. В этом контексте принято говорить о cohesion и coupling. А что насчёт качества связей?</p> <p><img src="/assets/img/blog/2025/2025-12-04-connascence.jpg" alt=""/></p> <p><a href="https://habr.com/ru/articles/894766/">Принцип каскадного снижения связанности</a>, предложенный Русланом Сафиным, контролирует баланс между cohesion и coupling на разных уровнях декомпозиции. Однако данный принцип, как и сами понятия cohesion и coupling, не отвечает на вопрос, насколько оправданы существующие связи, насколько они здоровы. Что если наличие связи между элементами не связывает их, а привязывает один к другому, сдерживая развитие обоих? Такие связи можно назвать обременительными, нездоровыми, порочными.</p> <p>Большую попытку категоризировать виды связей предпринял Meilir Page-Jones в своей книге “What Every Programmer Should Know About Object-Oriented Design” (1996), введя понятие <em>connascence</em> (от лат. “рождённые вместе”). В русскоязычной литературе можно встретить прямую транслитерацию — <em>коннасценция</em>, но я предпочитаю слово <em>взаимозависимость</em> (interdependence), т.к. сам автор сказал, что это точный синоним.</p> <blockquote> <p>Два элемента взаимозависимы, если для поддержания общей работоспособности они должны изменяться одновременно.</p> </blockquote> <p>Вместе с определением было предложено несколько <em>степеней взаимозависимости</em>, которые подразделяются на две группы: <em>статические</em> (в программном коде) и <em>динамические</em> (во время исполнения).</p> <blockquote> <p>Статические делятся по имени, типу, смыслу, порядку и алгоритму. Например, вызов метода и его определение (в классе) связаны по имени; функционально зависимые операторы связаны порядком; код клиента и сервера связан общим алгоритмом шифрования. Динамические делятся по порядку и времени выполнения, значению, ссылочной идентичности и способу взаимодействия. Например, отправить письмо невозможно до его создания; без синхронизации возникнет состояние гонки; синхронное или асинхронное взаимодействие. Подробные примеры см. на https://connascence.io/</p> </blockquote> <p>Как это можно привязать к практике?</p> <p>Предлагается уменьшать общую взаимозависимость путём декомпозиции на инкапсулированные элементы. В первую очередь удалять те связи, которые нарушают границы инкапсуляции, а для оставшихся связей — уменьшать степень взаимосвязанности, двигаться от динамических связей к статическим. И чем больше расстояние между элементами, тем слабей должна быть степень.</p> <p>Всё равно непонятно, давай рассмотрим пример!</p> <p>Короче, во-первых, нужно убедиться, что <a href="/blog/2025/decomposition-in-the-style-of-quantum-architecture/">декомпозиция сделана правильно</a>. Это уже решит большую часть проблем со связями или, наоборот, выявит недостатки. Во-вторых, выявленные взаимозависимости нужно удалить или свести их влияние к минимуму. Например, вы заметили, как модель одного ограниченного контекста передается без изменений в другой. Что будет, если эта модель поменяется в одном из контекстов? Возможно, стоит задуматься об инкапсуляции транспортного слоя между двумя контекстами? Самый банальный вариант — использовать DTO.</p> <p>Идея оценки связей путём их категоризации вполне разумна, но в оригинальном подходе есть недостатки. Во-первых, весь фокус смещается с архитектуры, которая должна определять правила игры, на детали реализации, качество и чистоту кода. Во-вторых, многие предложенные категории устарели и требуют пересмотра. Например, формы статической взаимозависимости уже давно неактуальны.</p> <p>Возьму на себя смелость сформулировать категории связей, актуальные на сегодняшний день:</p> <ul> <li><em>Явная/неявная.</em> Например, АОП провоцирует множество неявных связей и взаимополаганий.</li> <li><em>Статическая/динамическая.</em> Связь между компонентами предопределена или определяется во время исполнения.</li> <li><em>Асинхронная/синхронная.</em> Есть ли жесткая синхронизация взаимодействия компонентов, управляемая оркеструющим алгоритмом/механизмом.</li> <li><em>Надёжная/ненадёжная.</em> Насколько связь устойчива к различным сбоям и сверхнагрузкам, способна ли она восстанавливаться после такого.</li> </ul> <p>Список можно и нужно уточнять. Однако, как мне кажется, такая категоризация хорошо укладывается в концепцию архитектурных свойств и позволяет прорабатывать каждую категорию в отдельности. Так например, если нужна надёжная связь, то она сопряжена с такими эксплуатационными свойствами как <a href="/blog/2024/reliability-strength-stability/">надёжность, прочность, устойчивость</a> и адаптивность.</p> <hr/> <p>Желаю всем здоровых связей! А в следующий раз разберём, что с этим делать дальше.</p>]]></content><author><name></name></author><category term="post"/><category term="arch"/><summary type="html"><![CDATA[Думаю, многие пытались оценивать качество своей архитектуры, анализируя входящие и исходящие связи между элементами. В этом контексте принято говорить о cohesion и coupling. А что насчёт качества связей?]]></summary></entry><entry><title type="html">Декомпозиция в стиле квантовой архитектуры</title><link href="https://alexmas.github.io//blog/2025/decomposition-in-the-style-of-quantum-architecture/" rel="alternate" type="text/html" title="Декомпозиция в стиле квантовой архитектуры"/><published>2025-11-25T00:00:00+00:00</published><updated>2025-11-25T00:00:00+00:00</updated><id>https://alexmas.github.io//blog/2025/decomposition-in-the-style-of-quantum-architecture</id><content type="html" xml:base="https://alexmas.github.io//blog/2025/decomposition-in-the-style-of-quantum-architecture/"><![CDATA[<p>Какие способы декомпозиции на сервисы мы знаем? И самое главное: как именно сделать такую декомпозицию, в которой мы будем уверены?</p> <p><img src="/assets/img/blog/2025/2025-11-25-quantum-architecture.jpg" alt=""/></p> <p>Например, <a href="https://microservices.io/tags/pattern">К. Ричардсон</a> выделяет два основных подхода к декомпозиции:</p> <ul> <li><em>По бизнес-возможностям (by business capability).</em> Система разбивается на области, в которых бизнес генерирует прибыль. Бизнес-возможности организации определяют то, <strong>чем</strong> она является. Это более стабильное описание, в отличие от того, <strong>как</strong> организация ведёт свой бизнес. Например, обработка платежей будет всегда, и неважно, как именно она будет реализована.</li> <li><em>По поддоменам (by subdomains).</em> Способ декомпозиции системы на основе подходов Domain-driven design (DDD). Каждый поддомен определяет ограниченный контекст (bounded context), который соответствует одному сервису.</li> </ul> <blockquote> <p>Есть и более экзотические методы, которые я описывал ранее в статье “<a href="/blog/2025/msa-decomposition/">Как еще определять границы микросервисов</a>”.</p> </blockquote> <p>И несмотря на то, что всё делаешь “по науке”, продолжает терзать мысль: всё ли правильно и как в этом убедиться.</p> <p>Пожалуй, первое, что приходит на ум, это принципы ООП, сформулированные Р. Мартином, включая SRP (Single Responsibility) и CCP (Common Closure), а также его метрики успешности декомпозиции: <em>абстрактность</em> (соотношение абстрактных элементов к конкретным); <em>нестабильность</em> (соотношение исходящих связей компонента ко всем).</p> <p>Однако всё это мне никогда не давало полной уверенности. Позже я понял причину: они нацелены в первую очередь на техническую сторону вопроса, а не прикладную; оценку существующего кода, а не того, который предстоит написать.</p> <p>Думаю, по этой причине М. Ричардс и Н. Форд ввели понятие <em>архитектурного кванта</em> — уникального набора <a href="/blog/2025/basic-elements-of-an-architectural-framework/">архитектурных свойств</a>, действующих в рамках единицы развертывания — компонента (сервиса). При этом к свойствам предъявляются следующие требования.</p> <ul> <li> <p><em>Непредметный взгляд на проектирование.</em> Функциональные требования определяют, что должно делать приложение, а архитектурные свойства задают эксплуатационные критерии успеха, способствующие реализации требований.</p> </li> <li> <p><em>Влияние на структурные аспекты проектирования.</em> Архитектурное свойство является таковым, если оно влияет на структуру проекта. Например, в одном случае безопасность — это архитектурное свойство, а в другом нет. При обработке платежей через сторонний сервис безопасность важна, но она не повлияет на структуру проекта и будет ограничена технологическими мерами (шифрование, хэширование и т.п.). А вот самостоятельная реализация платежей, возможно, потребует структурной и физической изоляции платёжного сервиса.</p> </li> <li> <p><em>Ключевая или важная роль в успешности решения.</em> Архитектурное свойство является таковым, если оно необходимо для успешной реализации. Поддержка каждого свойства усложняет проектирование, поддержка множества свойств — бессмысленна. Выбранные свойства должны работать на вас, а не наоборот.</p> </li> </ul> <p>О чём это говорит? Производительность, масштабируемость, безопасность, надёжность, доступность — это только слова! В рамках отдельно взятого компонента они могут стать архитектурными свойствами только в том случае, если без них успех проекта невозможен. Понимание этого позволяет сфокусироваться на самых важных вещах и правильно расставить приоритеты.</p> <p>И как это помогает оценить успешность декомпозиции?</p> <p>Возьмите два взаимосвязанных сервиса и определите для них 3 самых важных архитектурных свойства. Каждый сервис — архитектурный квант, он определяет границы действия архитектурных свойств. Мысленно следуя по связи между сервисами, проверьте её адекватность. Если производительный сервис зависит от непроизводительного; безопасный — от небезопасного; масштабируемый — от немасштабируемого и т.д., значит, вы сделали что-то не так.</p> <hr/> <p>Всем добра и правильной декомпозиции! Если тема показалась интересной, поддержите меня. В следующий раз разберём, что есть помимо cohesion и coupling, и зачем это на практике.</p>]]></content><author><name></name></author><category term="post"/><category term="arch"/><summary type="html"><![CDATA[Какие способы декомпозиции на сервисы мы знаем? И самое главное: как именно сделать такую декомпозицию, в которой мы будем уверены?]]></summary></entry><entry><title type="html">Базовые элементы архитектурного фреймворка</title><link href="https://alexmas.github.io//blog/2025/basic-elements-of-an-architectural-framework/" rel="alternate" type="text/html" title="Базовые элементы архитектурного фреймворка"/><published>2025-11-17T00:00:00+00:00</published><updated>2025-11-17T00:00:00+00:00</updated><id>https://alexmas.github.io//blog/2025/basic-elements-of-an-architectural-framework</id><content type="html" xml:base="https://alexmas.github.io//blog/2025/basic-elements-of-an-architectural-framework/"><![CDATA[<p>Рано или поздно каждый уважающий себя разработчик задаётся вопросом: что такое архитектура ПО. И это не просто философия, это попытка систематизировать свой опыт, свои решения, ответить на вопрос, <strong>почему</strong> я поступал так, а не иначе. И как только находим ответ, последующие решения принимаются намного легче и уверенней.</p> <p><img src="/assets/img/blog/2025/2025-11-17-architecture-elements.jpg" alt=""/></p> <p>Многие определения архитектуры хоть и остроумны, но слишком абстрактны, чтобы из этого можно было бы извлечь значимую <em>пользу или найти практическую применимость</em>. Именно по этой причине мне импонирует как М. Ричардс и Н. Форд подошли к ответу на этот вопрос. Они не дают определение, а описывают составляющие архитектуры:</p> <blockquote> <p>Архитектура состоит из <strong>структуры</strong> системы в сочетании со <strong>свойствами</strong> архитектуры, которые должны поддерживаться системой, <strong>архитектурными решениями</strong> и <strong>принципами проектирования</strong>.</p> </blockquote> <p>Как видите, архитектура системы — это не точка на прямой, а точка в многомерном пространстве (согласно авторам — в 4-мерном пространстве). В этом и кроется причина, по которой мы не можем дать архитектуре односложное определение, но можем описать её с разных сторон, одновременно отвечая на вопрос, почему решение именно такое, какое есть. Невозможно составить полное представление об архитектуре системы только по одному измерению, их нужно рассматривать в комплексе.</p> <ol> <li> <p><em>Структура системы (structure of the system)</em> — тип используемого архитектурного стиля (или стилей). Например, микросервисная, многоуровневая, микроядерная и т.д. Стиль задаёт структуру, но не отвечает на вопрос “почему”. Без всего остального — это просто прямоугольники и стрелки.</p> </li> <li> <p><em>Свойства архитектуры (architecture characteristics)</em> — важнейшие черты системы, определяющие критерии успеха. Свойства не связаны с функциональными возможностями системы, но нужны для её корректной работы. Авторы называют их “словами с окончанием <code class="language-plaintext highlighter-rouge">-ость</code>” (англ. <code class="language-plaintext highlighter-rouge">-ility</code>): масштабируемость, производительность, доступность, безопасность и т.д.</p> </li> <li> <p><em>Архитектурные решения (architecture decisions)</em> — правила построения системы и ограничения. Например, “доступ к базе данных возможен только с уровня бизнес-логики”. Естественно, что решения не высечены в камне, и их можно и нужно подвергать сомнению. Главное, чтобы вокруг всего этого был выстроен процесс архитектурного контроля.</p> </li> <li> <p><em>Принципы проектирования (design principles)</em> — верхнеуровневые установки и рекомендации. Например, “для повышения производительности и ослабления связанности отдавать предпочтение асинхронному взаимодействию”; “для улучшения наблюдаемости использовать трассировку всех публичных методов сервиса” и т.п.</p> </li> </ol> <p>Как видите, все эти измерения взаимосвязаны: изменения в одном измерении, скорей всего, отразится в других. Задача архитектора — найти наиболее устойчивое положение в пространстве. И это положение, очевидно, будет совокупностью компромиссов, о которых все так любят говорить. Но главное, что поиск такого положения будет формировать целостный взгляд, <em>структурированный и осознанный ответ</em> на вопрос “почему”.</p> <p>Как это всё связано с практикой и при чём тут фреймворк? Посмотрите на свою систему сквозь призму этих измерений. Для каждого ограниченного контекста определите 3 самых важных архитектурных свойства. Если у каждого контекста свой набор свойств, а у вас “монолит”, тогда вам, возможно, следует задуматься о декомпозиции. Затем посмотрите на свои архитектурные решения и проверьте, способствуют ли они достижению выбранных свойств. А структура и принципы проектирования работают на общее дело? Я думаю, что вы уже поняли, как это работает.</p> <p>Резонный вопрос: “Почему только 4 измерения? Можно больше или меньше?” Больше, наверное, можно, меньше — не думаю. Главное, чтобы за всем этим вы видели технологию, которая позволяет в работе перейти от интуиции к системности.</p> <hr/> <p>После выхода статьи мне задали очень хороший вопрос. Ответ получился достаточно объемным, поэтому включаю его в качестве дополнения.</p> <p><strong>Вопрос:</strong> Не совсем понятно, чем архитектурные решения отличаются от принципов проектирования.</p> <p><strong>Ответ:</strong></p> <p>Ричардс и Форд ставят в центр внимания архитектурные свойства и предлагают выстраивать всё остальное вокруг этого. Иначе говоря, чтобы найти “устойчивое положение” нам нужно с чего-то начать. Фиксируем какой-то набор основных архитектурных свойств, а далее подбираем “координаты” по другим измерениям.</p> <p>Следуя этой концепции они определяют архитектурные решения как то, что влияет на структуру приложения или системы, включая выбор технологических средств, но при условии, что всё это влияет на выбранные архитектурные свойства, способствует их достижению. Также подмечают, что архитектурные решения подразумевают сбор информации для его обоснования, а также описание решения, необходимое и достаточное, чтобы убедить всех ответственных в его правильности. Говоря простым языком, архитектурное решение - это описание способа реализации чего-то в заданном прикладном контексте, но при условии, что это такое решение поддерживает определенное (выбранное) архитектурное свойство. Последнее дополнение проводит тонкую грань между архитектурным решением и техническим. Таким образом, выбор конкретной технологии не всегда архитектурное решение, но и не всегда техническое. Также даётся уточнение, что к архитектурно значимым решениям относятся те, которые влияют на структуру (1-е измерение); архитектурные свойства (2-е измерение), иногда называемые “нефункциональными требованиями”; зависимости (то, что определяет связанность между компонентами); API компонентов и их версионирование.</p> <p>А вот принципы проектирования - это руководство для разработчиков (guideline), рекомендации. Это уже не жёсткие правила, а какие-то “общие правила игры”. Архрешения не могут охватить всевозможные ситуации, поэтому заранее договариваемся о каких-то общих условиях игры. Например, можем сказать, что для при разработке придерживаемся SOLID-принципов; ведём разработку в стиле Domain-Driven Design; пишем приёмочные тесты, подменяя in/out-порты на заглушки; для тестирования публичного API используем контрактное тестирование с помощью Pact и т.д. Если архрешение задаёт чёткое правило (закон) в заданных условиях, то принципы задают общие правила поведения в большинстве возможных ситуаций.</p> <p>Можно ли принципы проектирования оформить в виде архитектурного решения (ADR)? Я думаю, что вполне можно, но, как мне кажется, их нужно структурно отделить. Например, поместить в какой-то отдельный каталог типа <code class="language-plaintext highlighter-rouge">commons</code>. Тогда новый член команды сможет быстро пройтись по базовым принципам, принятым в проекте, а не перебирать всю историю принятых решений.</p> <p>Нужно ли отделять архитектурные решения от технических? Или же все решения хранить в общей куче? В идеале, лучше отделять, чтобы чётко видеть то, что действительно влияет на архитектурные свойства. С другой стороны, такое разделение требует от нас максимальной дисциплинированности и педантичности, что на практике трудно достижимо. Наверное, компромиссным решением было бы введение в описание какого-то “уровня важности” (перечисление). И при выборе уровня важности можно было бы давать пояснение, что он значит. Я видел, что в крупных компаниях есть такая категоризация и отдельный процесс согласования решений для каждого уровня важности.</p>]]></content><author><name></name></author><category term="post"/><category term="arch"/><summary type="html"><![CDATA[Рано или поздно каждый уважающий себя разработчик задаётся вопросом: что такое архитектура ПО. И это не просто философия, это попытка систематизировать свой опыт, свои решения, ответить на вопрос, почему я поступал так, а не иначе. И как только находим ответ, последующие решения принимаются намного легче и уверенней.]]></summary></entry><entry><title type="html">Меры предосторожности при работе с РСУБД</title><link href="https://alexmas.github.io//blog/2025/safety-instruction-rdbms/" rel="alternate" type="text/html" title="Меры предосторожности при работе с РСУБД"/><published>2025-11-11T00:00:00+00:00</published><updated>2025-11-11T00:00:00+00:00</updated><id>https://alexmas.github.io//blog/2025/safety-instruction-rdbms</id><content type="html" xml:base="https://alexmas.github.io//blog/2025/safety-instruction-rdbms/"><![CDATA[<p>В пылу сражения легко забыть базовые меры предосторожности. Именно по этой причине разговоры о подобных вещах всегда актуальны. Предлагаю пройтись по базовым рекомендациям при работе с РСУБД. За основу взят зажигательный доклад “<a href="https://highload.ru/moscow/2025/abstracts/16855">Хайлоад на ровном месте</a>” и дополнен моими комментариями.</p> <p><img src="/assets/img/blog/2025/2025-11-11-safety-instruction-rdbms.jpg" alt=""/></p> <ul> <li> <p>Количество соединений с БД — это ограниченный ресурс, который контролируется как со стороны БД, так и со стороны приложения. Чем больше параллельных обращений к БД, тем больше должен быть пул соединений; иначе тот, кому не досталось соединения, зависнет до появления свободного соединения. Это значит, что будут таймауты, рост числа wait-потоков, рост потребления памяти (как минимум, на стек), рост потребления CPU (как минимум, на переключение контекста) и множество ярких эмоций.</p> </li> <li> <p>Idle-соединение — это неактивное соединение, которое захватило приложение, но не использует его. Например, захват соединения, затем длительные вычисления (или даже <em>поход во внешние сервисы</em>), и только в конце работа с БД. При таком подходе пул соединений будет израсходован очень быстро, и указанные выше проблемы возникнут практически сразу.</p> </li> <li> <p>Idle-in-transaction-соединение — это idle-соединение, в котором начали выполнение транзакции. Чаще всего такое провоцируют фреймворки. Например, аннотация <code class="language-plaintext highlighter-rouge">@Transactional</code> была помещена на верхний уровень процесса обработки запроса и захватывает не только работу с БД. Ко всем вышеуказанным проблемам сюда можно смело докидывать увеличение времени транзакции, длительные блокировки в БД, расходы на хранение версий (MVCC), раздувание WAL (Wall-Ahead Log).</p> </li> </ul> <blockquote> <p>Для “защиты” PostgreSQL от неблагонадёжных приложений разработан <a href="https://github.com/pgbouncer/pgbouncer">PgBouncer</a>, который проксирует взаимодействие с базой с целью пулинга соединений. Он позволяет активным соединениям вытеснять idle-соединения (но не idle-in-transaction), что увеличивает пропускную способность.</p> </blockquote> <ul> <li> <p>Если транзакция открывается только для чтения (SELECTs), то при <a href="/blog/2025/transaction-isolation-issues/">уровне изоляции</a> Read Committed её лучше убрать, т.к. “толку” от неё не будет, и это позволит избавиться от idle-in-transaction-соединений. А вот если нужен “толк”, тогда нужно повышать уровень изоляции, как минимум, до Repeatable Read, но такое нужно далеко не каждому.</p> </li> <li> <p>Для минимизации времени блокировок в БД все UPDATEs в коде нужно сместить ближе к месту закрытия транзакции. Конечно, это не избавит от idle-in-transaction-соединений, но это лучше, чем ничего.</p> </li> <li> <p>Пессимистичную блокировку следует применять, если много коллизий (высокая конкурентность при изменениях). Однако часто достаточно оптимистичной блокировки, которая избавляет от необходимости явного открытия обрамляющей транзакции, следовательно, от описанных выше проблем. Если же пессимистичная блокировка всё-таки нужна, то её можно реализовать не на уровне БД, а с помощью внешних механизмов (например, key-value-хранилищ).</p> </li> <li> <p>Медленные запросы могут исчерпать пул соединений, даже если таких запросов не очень много. Поэтому контролируем время выполнения запросов и анализируем планы запросов (explain). Частые проблемы: нет индексов на внешние ключи (foreign keys); используется <a href="https://jpoint.ru/archive/2022/talks/5d1a6b1be31c37d0e2b38f36b440fe15/">антипаттерн OrIsNull</a>; используется offset pagination (часто в сочетании с OrIsNull) вместо <a href="https://jpoint.ru/archive/2023/talks/7c6a25d123b441c68a48c1da157e3f38/">keyset pagination</a>; выбираются лишние данные (особенно <a href="https://www.postgresql.org/docs/current/storage-toast.html">TOAST</a>).</p> </li> </ul>]]></content><author><name></name></author><category term="post"/><category term="tip"/><category term="dev"/><category term="devops"/><summary type="html"><![CDATA[В пылу сражения легко забыть базовые меры предосторожности. Именно по этой причине разговоры о подобных вещах всегда актуальны. Предлагаю пройтись по базовым рекомендациям при работе с РСУБД. За основу взят зажигательный доклад “Хайлоад на ровном месте” и дополнен моими комментариями.]]></summary></entry><entry><title type="html">Ключевые темы HighLoad++ 2025</title><link href="https://alexmas.github.io//blog/2025/highload-2025/" rel="alternate" type="text/html" title="Ключевые темы HighLoad++ 2025"/><published>2025-11-10T00:00:00+00:00</published><updated>2025-11-10T00:00:00+00:00</updated><id>https://alexmas.github.io//blog/2025/highload-2025</id><content type="html" xml:base="https://alexmas.github.io//blog/2025/highload-2025/"><![CDATA[<p>2 дня конференции, 5000+ участников, 10 параллельных треков, 121 доклад, 10 мастер-классов и, конечно же, Fail-митап. (На котором, я, надеюсь, не сильно зафэйлился.) Вот таким стал прошедший HL++. Очень много информации, которую нужно обработать и структурировать.</p> <p><img src="/assets/img/blog/2025/2025-11-10-highload-2025.jpg" alt=""/></p> <p>Из примечательного. Онтико продолжает активно развивать тему воркшопов и мастер-классов. Их стало значительно больше, и они были оба дня. Это очень продуктивный формат, предполагающий постоянный интерактив. На будущее особенно рекомендую посещать те из них, которые не записываются.</p> <p>Много докладов было про AI (16). Очевидно, что эта тема стремительно врывается в нашу жизнь и диктует новые правила игры. Пока многие практические применения AI выглядят как обучение медведя катанию на велосипеде с целью его дальнейшей отправки на олимпиаду. Однако очень хорошо, что компании пытаются найти границы применимости AI. Короче, держим хвост по ветру и не теряем бдительности.</p> <p>Традиционно для HL++ много докладов про архитектуру и масштабируемость (34), про мои любимые базы данных (17), низкоуровневые и хардкорные оптимизации. Что-то я успел посмотреть очно, но большая часть находится в моём бэклоге.</p> <p>Были доклады, которые дали ответы на интересующие меня вопросы или подтвердили мою точку зрения. Наверняка, обо всём этом я напишу отдельные посты.</p> <p>А ещё для нас смертных устроили открытую встречу с министром цифрового развития М.И. Шадаевым. Разговор получился долгим и достаточно откровенным. Надеюсь, что видео будет доступно в ближайшее время.</p> <p>На финальной фотке виновники всего торжества, включая меня. Очень рад, что стал частью этой команды и мероприятия и, надеюсь, смог сделать его чуточку лучше.</p>]]></content><author><name></name></author><category term="post"/><category term="conf"/><summary type="html"><![CDATA[2 дня конференции, 5000+ участников, 10 параллельных треков, 121 доклад, 10 мастер-классов и, конечно же, Fail-митап. (На котором, я, надеюсь, не сильно зафэйлился.) Вот таким стал прошедший HL++. Очень много информации, которую нужно обработать и структурировать.]]></summary></entry><entry><title type="html">Как начать структурировать опыт</title><link href="https://alexmas.github.io//blog/2025/how-to-structure-experience/" rel="alternate" type="text/html" title="Как начать структурировать опыт"/><published>2025-10-31T00:00:00+00:00</published><updated>2025-10-31T00:00:00+00:00</updated><id>https://alexmas.github.io//blog/2025/how-to-structure-experience</id><content type="html" xml:base="https://alexmas.github.io//blog/2025/how-to-structure-experience/"><![CDATA[<p>Друзья, а вы пробовали коротко, ёмко и понятно описать причину технической проблемы или неудачи? Если нет, то я очень рекомендую. Это упражнение позволяет отрефлексировать и структурировать только что полученный опыт. В этот момент вы занимаетесь огранкой алмаза, золотодобычей своего профессионализма. На входе у вас тонны грубой руды, а на выходе один прекрасный алмаз, бесценная частичка ваших знаний. В итоге насмотренность конвертируется в повышение квалификации.</p> <p><img src="/assets/img/blog/2025/2025-10-28-fail-meetup.jpeg" alt=""/></p> <p>Упражнение очень простое. Заведите себе “дневник”, в котором в свободном, но желательно единообразном формате, описывайте ситуацию, последовательность ваших действий, причину произошедшего и итоговое решение. Описание должно быть кратким, структурированным, но очень ёмким и понятным. Через некоторое время вы обязательно заметите положительный эффект. Как минимум, сможете блеснуть зрелостью своего опыта или получить больше уверенности на собеседовании.</p> <p>На следующей неделе, 6 и 7 ноября пройдёт крупнейшая IT-конференция для разработчиков высоконагруженных систем — <a href="https://highload.ru/">HighLoad++</a>. Я буду выступать на <a href="https://highload.ru/moscow/2025/abstracts/17079">Fail-митапе</a>, где расскажу про свой самый крупный профессиональный фэйл за прошедшие 1.5 года. Многие знают, что подобные рассказы часто оказываются более ценными, чем красочный доклад про успешный успех. Fail-секция — это шанс быстро получить “огранённый” ценный опыт и не повторить чужих ошибок. Для меня этот формат в новинку, однако я надеюсь, что рассказ будет не только интересным и смешным, но и полезным.</p> <p>Если будете вместе со мной на конференции, пишите. Познакомимся ближе, буду рад общению. Как минимум, приходите на Fail-митап.</p>]]></content><author><name></name></author><category term="post"/><category term="tip"/><category term="conf"/><summary type="html"><![CDATA[Друзья, а вы пробовали коротко, ёмко и понятно описать причину технической проблемы или неудачи? Если нет, то я очень рекомендую. Это упражнение позволяет отрефлексировать и структурировать только что полученный опыт. В этот момент вы занимаетесь огранкой алмаза, золотодобычей своего профессионализма. На входе у вас тонны грубой руды, а на выходе один прекрасный алмаз, бесценная частичка ваших знаний. В итоге насмотренность конвертируется в повышение квалификации.]]></summary></entry><entry><title type="html">Вспомогательная таблица для ускорения выборки</title><link href="https://alexmas.github.io//blog/2025/data-seive/" rel="alternate" type="text/html" title="Вспомогательная таблица для ускорения выборки"/><published>2025-10-28T00:00:00+00:00</published><updated>2025-10-28T00:00:00+00:00</updated><id>https://alexmas.github.io//blog/2025/data-seive</id><content type="html" xml:base="https://alexmas.github.io//blog/2025/data-seive/"><![CDATA[<p>Сегодня поделюсь методом оптимизации выборки больших данных, который кажется очевидным, но не всегда приходит в голову. Этот подход я использовал в связке с ClickHouse, однако он подходит для большинства хранилищ данных.</p> <p><img src="/assets/img/blog/2025/2025-10-28-data-seive.jpeg" alt=""/></p> <h2 id="контекст">Контекст</h2> <p>Имеется агрегат, с которым может быть связано много данных, которые накапливаются с течением длительного времени. Например, пациент и его документы; датчик и его показания.</p> <p>Обычно такие данные хранят в табличном виде, и в рамках такой таблицы есть связка между идентификатором агрегата, ассоциированным элементом и временем создания элемента. Например, таблица документов хранит ссылку на пациента и время создания документа; таблица показаний хранит ссылку на датчик и время снятия показаний.</p> <p>Вполне вероятно, что в целях нормального распределения данных, их партиционирование будет выполнено по времени создания элементов данных (например, времени создания документа; времени снятия показаний). Гранулярность партиционирования определяется выбранной БД, объемом данных и интенсивностью их поступления.</p> <p>Пример таблицы с показаниями датчиков в ClickHouse:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">history</span> <span class="p">(</span>
  <span class="n">tag</span> <span class="n">String</span><span class="p">,</span>
  <span class="nb">date</span> <span class="nb">Date</span> <span class="k">DEFAULT</span> <span class="n">toDate</span><span class="p">(</span><span class="nb">time</span><span class="p">),</span>
  <span class="nb">time</span> <span class="n">DateTime64</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'UTC'</span><span class="p">),</span>
  <span class="n">value</span> <span class="n">Float64</span>
<span class="p">)</span>
<span class="n">ENGINE</span> <span class="o">=</span> <span class="n">MergeTree</span><span class="p">()</span>
<span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">toYYYYMM</span><span class="p">(</span><span class="nb">date</span><span class="p">)</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="nb">date</span><span class="p">,</span> <span class="nb">time</span><span class="p">)</span>
</code></pre></div></div> <h2 id="проблемы">Проблемы</h2> <p>В системе очень часто (или всегда) запрашивают данные без указания временного диапазона, но, возможно, с указанием дополнительных фильтров. Например, получить документы по пациенту у терапевта; получить показания датчика со значениями выше нормы.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">tag</span><span class="p">,</span> <span class="nb">time</span><span class="p">,</span> <span class="n">value</span>
<span class="k">FROM</span> <span class="n">history</span>
<span class="k">WHERE</span> <span class="n">tag</span> <span class="o">=</span> <span class="p">:</span><span class="n">tag</span> <span class="k">AND</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="p">:</span><span class="n">value</span>
</code></pre></div></div> <p>Без указания временных границ приходится сканировать все партиции за всё время. В результате запрос выполняется очень долго и создает большую нагрузку на I/O.</p> <h2 id="решение">Решение</h2> <p>Создать производную таблицу с “подсказками”, по которым можно будет существенно ограничить количество партиций при выборке данных. По такой таблице можно определять наличие данных у агрегата за весь период его существования. Например, дни, за которые у пациента/датчика есть документы/показания.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="n">MATERIALIZED</span> <span class="k">VIEW</span> <span class="n">history_info</span>
<span class="n">ENGINE</span> <span class="o">=</span> <span class="n">ReplacingMergeTree</span><span class="p">()</span>
<span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">toYYYYMM</span><span class="p">(</span><span class="nb">date</span><span class="p">)</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="nb">date</span><span class="p">)</span>
<span class="n">POPULATE</span>
<span class="k">AS</span>
<span class="k">SELECT</span> <span class="n">tag</span><span class="p">,</span> <span class="nb">date</span>
<span class="k">FROM</span> <span class="n">history</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">tag</span><span class="p">,</span> <span class="nb">date</span>
</code></pre></div></div> <p>По такой таблице, например, можно очень быстро найти левую границу данных:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">min</span><span class="p">(</span><span class="nb">date</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">history_info</span>
<span class="k">WHERE</span> <span class="n">tag</span> <span class="o">=</span> <span class="p">:</span><span class="n">tag</span>
</code></pre></div></div> <p>Эту информацию можно использовать как подсказку в основном запросе:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">tag</span><span class="p">,</span> <span class="nb">time</span><span class="p">,</span> <span class="n">value</span>
<span class="k">FROM</span> <span class="n">history</span>
<span class="k">WHERE</span> <span class="n">tag</span> <span class="o">=</span> <span class="p">:</span><span class="n">tag</span> <span class="k">AND</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="p">:</span><span class="n">value</span>
  <span class="k">AND</span> <span class="nb">date</span> <span class="o">&gt;=</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="k">min</span><span class="p">(</span><span class="nb">date</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">history_info</span>
    <span class="k">WHERE</span> <span class="n">tag</span> <span class="o">=</span> <span class="p">:</span><span class="n">tag</span>
  <span class="p">)</span>
</code></pre></div></div> <p>Подобное решение можно адаптировать и под другие варианты партиционирования данных, а производная таблица “подсказок” может быть более или менее информативной. Основная её цель — это существенно сократить объем выборки без потери качества результата.</p> <h2 id="плюсы">Плюсы</h2> <ul> <li>Существенное ускорение времени выполнения запроса.</li> <li>Существенное снижение нагрузки на I/O.</li> </ul> <h2 id="минусы">Минусы</h2> <ul> <li>Усложнение кода приложения для создания производной таблицы, наполнения её данными и поддержания их в актуальном состоянии. Если данная проблема решается средствами СУБД, как, например, в ClickHouse, то данный минус несущественный.</li> <li>Увеличение размера хранимых данных.</li> </ul>]]></content><author><name></name></author><category term="post"/><category term="tip"/><category term="db"/><summary type="html"><![CDATA[Сегодня поделюсь методом оптимизации выборки больших данных, который кажется очевидным, но не всегда приходит в голову. Этот подход я использовал в связке с ClickHouse, однако он подходит для большинства хранилищ данных.]]></summary></entry><entry><title type="html">Второй закон архитектуры</title><link href="https://alexmas.github.io//blog/2025/second-law-of-architecture/" rel="alternate" type="text/html" title="Второй закон архитектуры"/><published>2025-10-24T00:00:00+00:00</published><updated>2025-10-24T00:00:00+00:00</updated><id>https://alexmas.github.io//blog/2025/second-law-of-architecture</id><content type="html" xml:base="https://alexmas.github.io//blog/2025/second-law-of-architecture/"><![CDATA[<p>Вчера в канале Руслана Сафина вышел <a href="https://t.me/rsa_enc/387">пост</a>, в котором он, в том числе, поднял тему, каким должен быть ИТ-архитектор, чтобы его не заменили на ИИ в (ближайшем) будущем.</p> <p><img src="/assets/img/blog/2025/2025-10-24-knowledge-tree.jpeg" alt=""/></p> <p>Скажу сразу, что я согласен с его постановкой. Для меня всегда была важна структура знаний — дерево знаний, а технологические вещи я всегда считал за листья, которые меняются у дерева каждый сезон. Не держись за лист, иначе осенью тебя унесет ветром вместе с ним; держись за дерево и его корни. Познай искусство бонсай и взращивай своё дерево знаний, чтобы оно было крепким и здоровым. Рост не должен быть хаотичным, он должен быть последовательным, от корней к листьям, а не наоборот.</p> <p>Много раз становился свидетелем жалоб, что не успевают за прогрессом; что не могут понять, как работают инструменты, т.к. за частным не видели общего. В этой связи всегда давал один совет — пойти по пути структуризации знаний и найти место инструмента в дереве знаний. Понять, откуда выросла эта ветка, и почему так сложилось. Для этого нужны фундаментальные знания, а их проще получить через книги, а не статьи в стиле “how to”.</p> <p>По правде говоря, я тоже не успеваю за прогрессом и тоже жалуюсь на всё это. :) Но в этот момент стараюсь отложить непонятную вещь и начать с каких-то базовых основ. Я понимаю, что потрачу больше времени, но так я инвестирую в себя и на выходе получаю осознанный и качественный результат. Иначе в голове будет полная каша, а я очень ленивый, чтобы помнить все нюансы работы того или иного инструмента.</p> <p>Пока я думал над всем этим, я понял, что мы открыли “второй закон архитектуры”, который был сформулирован Нилом Фордом и Марком Ричардсом:</p> <blockquote> <p><strong>Почему</strong> важнее, чем <strong>как</strong>.</p> </blockquote> <p>(Первый закон: “Всё в архитектуре соткано из компромиссов”.)</p> <p>Подобные инсайты запускают очередную структуризацию мыслей. И круто, что приходим к одному и тому же, пусть и разными путями.</p>]]></content><author><name></name></author><category term="post"/><category term="view"/><category term="arch"/><summary type="html"><![CDATA[Вчера в канале Руслана Сафина вышел пост, в котором он, в том числе, поднял тему, каким должен быть ИТ-архитектор, чтобы его не заменили на ИИ в (ближайшем) будущем.]]></summary></entry><entry><title type="html">Решардирование данных через промежуточный топик</title><link href="https://alexmas.github.io//blog/2025/resharding-data/" rel="alternate" type="text/html" title="Решардирование данных через промежуточный топик"/><published>2025-10-22T00:00:00+00:00</published><updated>2025-10-22T00:00:00+00:00</updated><id>https://alexmas.github.io//blog/2025/resharding-data</id><content type="html" xml:base="https://alexmas.github.io//blog/2025/resharding-data/"><![CDATA[<p>Есть интересный алгоритм, который позволяет не только увеличить пропускную способность потока обработки данных, но и значительно сократить нагрузку на сеть и брокер сообщений.</p> <p><img src="/assets/img/blog/2025/2025-10-22-resharding-data-16-9.png" alt=""/></p> <h2 id="контекст">Контекст</h2> <p>Существует множество серверов для обслуживания большого потока пользовательских запросов. Например, для обработки поисковых запросов, сбора клиентской телеметрии, создания документов в крупной медицинской системе и т.д. Помимо основной логики обработки формируется лог запросов для их последующего (асинхронного) анализа. Лог запросов формируется в виде топика <a href="/blog/2024/log-and-queue-based-brokers/">Log-based-брокера</a>, например, в Apache Kafka, который обслуживает набор специализированных серверов-обработчиков. Такая обработка может формировать, например, топ поисковых запросов или список интересов пользователя.</p> <p>Таким образом, одно подмножество серверов — продюсеры; второе — консюмеры. Чаще всего в таких случаях топики партиционируют так, чтобы консюмеру было удобно получать и обрабатывать данные. Такое удобство может диктоваться необходимостью пакетной обработки, <a href="/blog/2025/reliable-delivery/">соблюдения порядка событий</a>, <a href="/blog/2024/data-flow-speeding-up/">локальностью данных</a> и т.п.</p> <h2 id="проблемы">Проблемы</h2> <ul> <li>Продюсеры берут на себя обязательства по обеспечению удобства обработки данных топика, в который они пишут.</li> <li>Возможно снижение эффективности записи в топик, если топик имеет множество партиций, а ключ партиционирования варьируется в большом диапазоне. Например, партиционирование по идентификатору пользователя или документа. Из-за этого продюсер будет накапливать пачки сообщений меньших размеров для записи в конкретную партицию. При большом разбросе ключей запись в каждую партицию может идти без пакетирования, что увеличивает транспортные расходы и нагрузку на брокер.</li> <li>Возможна слишком большая нагрузка на брокер и сеть, если количество продюсеров и партиций велико. Каждый продюсер создаёт TCP-соединение с брокером, отвечающим за партицию, в которую производится запись. При большом количестве партиций для <code class="language-plaintext highlighter-rouge">P</code> продюсеров и <code class="language-plaintext highlighter-rouge">B</code> брокеров будет создано <code class="language-plaintext highlighter-rouge">P*B</code> соединений. В результате при масштабировании системы могут существенно возрасти транспортные расходы, нагрузка на брокер и сеть.</li> </ul> <h2 id="решение">Решение</h2> <p>Продюсер должен писать не в целевой топик, а в промежуточный, который будет удобен для записи. Промежуточный топик обслуживается ограниченным количеством специализированных консюмеров, задача которых — переложить данные из промежуточного топика (удобного для записи) в целевой (удобный для обработки). Ключ партиционирования промежуточного топика должен варьироваться в небольшом диапазоне. Например, партиционирование по идентификатору продюсера.</p> <p>Этот подход называется решардированием данных на основе промежуточного агрегирующего слоя.</p> <h2 id="плюсы">Плюсы</h2> <ul> <li>Продюсер пишет так, как ему удобно.</li> <li>Используется пакетная запись. Вариативность ключей партиционирования промежуточного топика ограничена сильней, чем целевого. Следовательно, при интенсивной записи гораздо больше шансов, что продюсер будет отправлять в партиции промежуточного топика более объемные пакеты.</li> <li>Нагрузка на брокер и сеть снижается. Из-за небольшого количества уникальных ключей партиционирования промежуточного топика, количество его партиций меньше количества партиций целевого топика. Следовательно, продюсеры будут подключаться лишь к ограниченному количеству брокеров, а не ко всем, как раньше. Одновременно с этим, количество обработчиков промежуточного топика также меньше числа продюсеров, что также снижает количество соединений к брокерам.</li> </ul> <blockquote> <p>Например, для обработки пользовательских запросов необходимо поднять <code class="language-plaintext highlighter-rouge">P=1000</code> серверов. Пусть всего имеется <code class="language-plaintext highlighter-rouge">B=10</code> брокеров; а лог запросов партиционирован по идентификатору пользователя и имеет <code class="language-plaintext highlighter-rouge">1000</code> партиций. Скорей всего, в такой системе будет около <code class="language-plaintext highlighter-rouge">P*B=1000*10=10000</code> TCP-соединений между продюсерами и брокерами (т.к. каждый продюсер будет соединён с каждым брокером).</p> <p>Если добавить промежуточный топик с партиционированием по продюсеру, то уникальных ключей будет <code class="language-plaintext highlighter-rouge">P=1000</code>. Допустим, мы решили, что для такого топика достаточно сделать <code class="language-plaintext highlighter-rouge">10</code> партиций и, соответственно, до <code class="language-plaintext highlighter-rouge">С=10</code> промежуточных консюмеров. В такой системе количество TCP-соединений с брокерами будет не более <code class="language-plaintext highlighter-rouge">P*1+С*B=1000*1+10*10=1010</code>, что на порядок меньше предыдущего варианта.</p> </blockquote> <h2 id="минусы">Минусы</h2> <ul> <li>Усложнение архитектуры. Увеличивается кодовая база, усложняется алгоритм обработки, деплой и обслуживание приложения.</li> <li>Отсутствие гарантий ACID. Соответственно, всё те же проблемы с гарантиями доставки, дублированием, идемпотентностью и т.п. <em>(В YDB Topics эта проблема <a href="https://habr.com/ru/companies/ydb/articles/949662/">решена</a>.)</em></li> <li>Увеличение времени доставки данных в целевой топик.</li> <li>Увеличение размера хранимых данных.</li> </ul>]]></content><author><name></name></author><category term="post"/><category term="tip"/><category term="arch"/><category term="tech"/><summary type="html"><![CDATA[Есть интересный алгоритм, который позволяет не только увеличить пропускную способность потока обработки данных, но и значительно сократить нагрузку на сеть и брокер сообщений.]]></summary></entry></feed>