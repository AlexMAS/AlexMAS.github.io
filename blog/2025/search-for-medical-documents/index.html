<!DOCTYPE html> <html lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Первичный анализ задачи поиска медицинских документов | Александр Межов </title> <meta name="author" content="Александр Межов"> <meta name="description" content="Сегодня предлагаю рассмотреть вполне конкретную задачу из реального проекта. Думаю, что подобный кейс достаточно интересен и его можно рассматривать для прокачки своих навыков по System Design."> <meta name="keywords" content="поиск, документы, метаданные, ClickHouse, партиционирование"> <meta property="og:site_name" content="Александр Межов"> <meta property="og:type" content="article"> <meta property="og:title" content="Первичный анализ задачи поиска медицинских документов"> <meta property="og:url" content="https://alexmas.github.io//blog/2025/search-for-medical-documents/"> <meta property="og:description" content="Сегодня предлагаю рассмотреть вполне конкретную задачу из реального проекта. Думаю, что подобный кейс достаточно интересен и его можно рассматривать для прокачки своих навыков по System Design."> <meta property="og:image" content="https://alexmas.github.io//assets/img/blog/2025/2025-12-25-search-service.jpg"> <meta property="og:locale" content="ru"> <meta name="twitter:card" content="summary"> <meta name="twitter:title" content="Первичный анализ задачи поиска медицинских документов"> <meta name="twitter:description" content="Сегодня предлагаю рассмотреть вполне конкретную задачу из реального проекта. Думаю, что подобный кейс достаточно интересен и его можно рассматривать для прокачки своих навыков по System Design."> <meta name="twitter:image" content="https://alexmas.github.io//assets/img/blog/2025/2025-12-25-search-service.jpg"> <script type="application/ld+json">
    {
        "author":
        {
            "@type": "Person",
            "name": "Александр Межов"
        },
        "url": "https://alexmas.github.io//blog/2025/search-for-medical-documents/",
        "@type": "BlogPosting",
        "description": "Сегодня предлагаю рассмотреть вполне конкретную задачу из реального проекта. Думаю, что подобный кейс достаточно интересен и его можно рассматривать для прокачки своих навыков по System Design.",
        "headline": "Первичный анализ задачи поиска медицинских документов",
        
        "sameAs": "https://t.me/arch_and_dev",
        
        "name": "Александр Межов",
        "@context": "https://schema.org"
    }
  </script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?27787be15f1341be1c13406838f8df52"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://alexmas.github.io//blog/2025/search-for-medical-documents/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Александр</span> Межов </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">Обо мне </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Архитектоника в ИТ </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Публикации и выступления </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Первичный анализ задачи поиска медицинских документов</h1> <p class="post-meta"> </p> <p class="post-tags"> <a href="/blog/2025"><i class="fa-solid fa-calendar fa-sm"></i> 2025</a>-12-24   ·   <a href="/blog/tag/arch"> <i class="fa-solid fa-hashtag fa-sm"></i> arch</a>   <a href="/blog/tag/db"> <i class="fa-solid fa-hashtag fa-sm"></i> db</a>   ·   <a href="/blog/category/article"> <i class="fa-solid fa-tag fa-sm"></i> article</a> </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"> <a href="#%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0">Задача</a> <ul> <li class="toc-entry toc-h3"><a href="#%D1%83%D1%82%D0%BE%D1%87%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9">Уточнение требований</a></li> <li class="toc-entry toc-h3"><a href="#%D0%BD%D0%B5%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Нефункциональные требования</a></li> <li class="toc-entry toc-h3"> <a href="#%D0%B8%D0%B7%D0%B2%D0%B5%D1%81%D1%82%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B-%D0%B8-%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F">Известные проблемы и ограничения</a> <ul> <li class="toc-entry toc-h4"><a href="#%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B1%D0%B0%D0%B7%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Реляционные базы данных</a></li> <li class="toc-entry toc-h4"><a href="#%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5-%D0%B1%D0%B0%D0%B7%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Поисковые базы данных</a></li> </ul> </li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B9">Анализ условий</a> <ul> <li class="toc-entry toc-h3"><a href="#%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Общие требования</a></li> <li class="toc-entry toc-h3"><a href="#%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0">Особенности запроса</a></li> <li class="toc-entry toc-h3"><a href="#%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F">Особенности хранения</a></li> <li class="toc-entry toc-h3"><a href="#%D0%B0%D0%BA%D1%82%D1%83%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B0">Актуализация поискового индекса</a></li> <li class="toc-entry toc-h3"><a href="#%D0%BF%D0%BE%D0%BF%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D1%8B">Популяционные запросы</a></li> <li class="toc-entry toc-h3"><a href="#%D0%B7%D0%B0%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B0%D1%86%D0%B8%D0%B8">Задержка индексации</a></li> <li class="toc-entry toc-h3"><a href="#%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B0">Размер индекса</a></li> <li class="toc-entry toc-h3"><a href="#%D0%BC%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F">Масштабирование хранения</a></li> <li class="toc-entry toc-h3"><a href="#%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C-%D1%86%D0%B5%D0%BB%D0%BE%D1%81%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8">Контроль целостности</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D1%83">Требования к хранилищу</a></li> <li class="toc-entry toc-h2"><a href="#%D0%B2%D1%8B%D0%B1%D0%BE%D1%80-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B0">Выбор хранилища</a></li> <li class="toc-entry toc-h2"><a href="#%D0%BF%D0%BB%D0%B0%D0%BD-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">План реализации</a></li> <li class="toc-entry toc-h2"><a href="#%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5">Послесловие</a></li> </ul> </div> <hr> <div id="markdown-content"> <p>Сегодня предлагаю рассмотреть вполне конкретную задачу из реального проекта. Думаю, что подобный кейс достаточно интересен и его можно рассматривать для прокачки своих навыков по System Design.</p> <p><img src="/assets/img/blog/2025/2025-12-25-search-service.jpg" alt=""></p> <p>Сразу скажу, что мы ещё не полностью решили описанную ниже задачу. Представленное решение — лишь один из возможных вариантов, черновик, который ещё не проверен на практике. Однако, выполнив достаточно подробный анализ, я решил поделиться им с вами, а не оставлять пылиться результаты проделанной работы у себя в столе. В статье постарался адаптировать материал, чтобы он был понятен широкому кругу читателей и не требовал глубокого погружения в предметную область. Надеюсь, у меня получилось, и желаю вам приятного чтения.</p> <h2 id="задача">Задача</h2> <p>Необходимо реализовать быстрый поиск по метаданным медицинских документов.</p> <p>Грубо говоря, метаданные описывают содержимое документов с помощью набора атрибутов, которые можно поделить на три категории:</p> <ul> <li>общие атрибуты;</li> <li>атрибуты, характерные для типа документа;</li> <li>атрибуты, описывающие связи с другими документами.</li> </ul> <p>Небольшая часть атрибутов присутствует у всех документов, например, “ID пациента”, “дата создания”, “тип документа”, “состояние” и т.д. Однако документы бывают разных типов, соответственно, атрибутивный состав метаданных разных типов документов — разный. Например, состав атрибутов для “Осмотра терапевта” отличается от “Осмотра кардиолога”. Описание семантических связей между документами также является частью метаописания. Например, “Направление на анализы” может содержать ссылки на результаты (и наоборот).</p> <p>Типы данных атрибутов — скаляры (в основном целые числа разной разрядности, строки) и списки скаляров. Атрибутивный состав может меняться динамически, во время работы системы, без необходимости её повторного развертывания.</p> <p>Поиск документов сводится к их фильтрации по атрибутам. Условие фильтрации может быть сложным логическим выражением — произвольной комбинацией операторов <code class="language-plaintext highlighter-rouge">OR</code>/<code class="language-plaintext highlighter-rouge">AND</code>/<code class="language-plaintext highlighter-rouge">NOT</code>. Поиск по связанным документам не производится, но может производиться проверка наличия связей.</p> <p>Поисковые запросы можно поделить на две категории:</p> <ul> <li> <em>Поиск по пациенту</em> — это поиск внутри электронной медицинской карты пациента, фильтрация документов определенного пациента — подавляющая часть запросов. Например: “найти все обращения пациента к кардиологу”.</li> <li> <em>Популяционный поиск</em> — это фильтрация документов без указания пациента — малая часть запросов. Например, “найти документы, подписанные выбранным врачом”; “найти все больничные листы, выданные указанной поликлиникой за прошедший месяц”.</li> </ul> <p><img src="/assets/img/blog/2025/2025-12-25-search-service-01.png" alt=""></p> <p>Важно, что подавляющая часть поисковых запросов идёт без указания периода создания документов. Иначе говоря, практически никогда не бывает запросов вида: “найди документы, созданные за последний год”, “за последний месяц” и т.п.</p> <p>По умолчанию результат поиска должен быть отсортирован по дате создания документов в обратном хронологическом порядке (от новых документов к старым).</p> <p>Документы могут изменяться несколько раз подряд. Нужно, чтобы поиск возвращал релевантные данные, игнорируя старые версии документов.</p> <p>В идеале решение должно предполагать возможность постраничной выборки.</p> <h3 id="уточнение-требований">Уточнение требований</h3> <p>Разрабатываемая медицинская система уже имеет функцию поиска. Она реализована на базе SQL-хранилища, выполняет все функциональные требования, но работает крайне медленно. Поисковый запрос трансформируется в SQL-запрос, который представляет собой оператор <code class="language-plaintext highlighter-rouge">SELECT</code> с множественными <code class="language-plaintext highlighter-rouge">INNER JOIN</code> и операциями фильтрации, которые соответствуют переданному запросу.</p> <p>Существующее решение таково, что поиск осуществляется по операционному хранилищу, следовательно, документ доступен для поиска сразу после сохранения. Возможно, что некоторые пользователи сервиса рассчитывают на это поведение, поэтому целевое решение должно стремиться к минимальной задержке между моментом, когда данные были изменены и когда они стали доступны для поиска.</p> <p><img src="/assets/img/blog/2025/2025-12-25-search-service-02.png" alt=""></p> <p>Система существует долгие годы, и так сложилось, что некоторые смежные продукты, обнаружив <a href="/blog/2025/optimistic-architecture/">чрезмерную гибкость API</a> сервиса поиска, стали отправлять популяционные запросы. Однако в общем случае популяционный поиск не является задачей медицинской системы, т.к. для её эффективного решения нужно строить <em>витрины данных</em>, а вид витрин сильно зависит от специфических потребностей отдельно взятого продукта. Следовательно, смежные продукты должны самостоятельно организовывать необходимые им витрины данных, а медицинская система, в свою очередь, обязана лишь предоставлять механизм, необходимый для организации таких пользовательских витрин. Например, система может публиковать асинхронные уведомления об изменениях документов.</p> <p>Таким образом, принято стратегическое архитектурное решение, что смежные продукты будут постепенно отказываться от популяционных запросов, организуя собственные витрины данных. Соответственно, нужно идентифицировать всех таких пользователей, уведомить их о необходимости доработок и обговорить сроки реализации.</p> <p><img src="/assets/img/blog/2025/2025-12-25-search-service-03.png" alt=""></p> <p>Между тем, популяционный поиск существует, поэтому искомое решение должно учитывать этот сценарий и обеспечивать его должную производительность. Даже самые оптимистичные прогнозы говорят о том, что отказ от популяционных запросов может занять несколько лет. Это большой срок, чтобы игнорировать необходимость реализации данной функциональности.</p> <h3 id="нефункциональные-требования">Нефункциональные требования</h3> <p>Текущая база данных такова:</p> <ul> <li>Количество пациентов: <code class="language-plaintext highlighter-rouge">25 000 000</code> </li> <li>Количество документов: <code class="language-plaintext highlighter-rouge">5 000 000 000</code> </li> <li>Количество общих атрибутов: до <code class="language-plaintext highlighter-rouge">20</code> </li> <li>Количество дополнительных атрибутов: до <code class="language-plaintext highlighter-rouge">50</code> (чаще до <code class="language-plaintext highlighter-rouge">5</code>)</li> <li>Количество связей: до <code class="language-plaintext highlighter-rouge">100</code> (чаще до <code class="language-plaintext highlighter-rouge">2</code>)</li> </ul> <p>Динамика прироста базы данных:</p> <ul> <li>Прирост населения в год: <code class="language-plaintext highlighter-rouge">120 000</code> </li> <li>Прирост документов в день: <code class="language-plaintext highlighter-rouge">5 000 000</code> </li> <li>Количество лет для прогноза: <code class="language-plaintext highlighter-rouge">10</code> </li> </ul> <p>Показатели производительности:</p> <ul> <li>Показатель нагрузки: <code class="language-plaintext highlighter-rouge">1000</code> RPS.</li> <li>Время поиска по пациенту: ≤ <code class="language-plaintext highlighter-rouge">200</code> ms (P99).</li> <li>Время популяционного поиска: ≤ <code class="language-plaintext highlighter-rouge">1000</code> ms (P99).</li> <li>Лимит на количество строк в результате поиска: <code class="language-plaintext highlighter-rouge">2000</code> </li> <li>Задержка сохранил/нашёл: ≤ <code class="language-plaintext highlighter-rouge">1000</code> ms</li> </ul> <h3 id="известные-проблемы-и-ограничения">Известные проблемы и ограничения</h3> <p>Для понимания последующих выводов необходимо добавить расширенный контекст: что уже пробовали, с какими проблемами и ограничениями сталкивались. Во многом благодаря этому и появилась потребность в решении рассматриваемой задачи.</p> <h4 id="реляционные-базы-данных">Реляционные базы данных</h4> <p>Большинство запросов имеет фильтр по идентификатору пациента, а документов у одного пациента не так много. Если посмотреть на исходные данные, в среднем 200 документов на каждого пациента. С такими запросами может справиться и реляционная база данных, достаточно добавить индекс на идентификатор пациента, и он существенно ограничит размер выборки. Однако есть несколько обстоятельств, почему такой вариант не рассматривается.</p> <ul> <li> <p>С ростом хранилища понадобится партиционирование и шардирование. С этим могли бы справиться <a href="/blog/2025/distributed-sql-databases/">распределённые SQL-базы</a>, но заказчик установил ограничение, и можно использовать только PostgreSQL, а с его масштабированием есть <a href="/blog/2025/what-s-wrong-with-postgresql/">вполне определённые трудности</a>.</p> </li> <li> <p>Проблема с множественными <code class="language-plaintext highlighter-rouge">INNER JOIN</code> никуда не уходит. Как показала практика эксплуатации текущего решения на базе SQL-хранилища, это заметно снижает производительность. Делать денормализацию (и “широкие таблицы”) под каждый тип документа не вариант, т.к. типов очень много и они появляются динамически. Гораздо проще хранить вариативный состав атрибутов в JSON-колонке.</p> </li> <li> <p>Для решения проблемы с популяционными запросами придётся делать срезы данных — отдельные <a href="/blog/2025/data-seive/">вспомогательные таблицы</a>, которые будут хранить данные в удобном для чтения виде. Скорей всего, само приложение будет ответственно за создание и актуализацию таких срезов.</p> </li> </ul> <h4 id="поисковые-базы-данных">Поисковые базы данных</h4> <p>Решать задачу поиска без рассмотрения такой базы, как Elasticsearch, было бы глупо. На самом деле новое решение, которое разрабатывается в настоящий момент, как раз основано на использовании Elasticsearch. Между тем с его использованием в данной задаче есть проблемы.</p> <ul> <li> <p>В идеале индексируемые данные должны быть append-only: добавляться и никогда не изменяться. Как только появляется необходимость обновления записи, производительность существенно падает, вызывая крайне негативный отклик на уровне I/O. Между тем, медицинские документы обновляются. И если в индекс производить только добавление, то в нём появляются старые версии документов, которые нужно фильтровать или удалять.</p> </li> <li> <p>Сложные логические выражения в фильтре являются настоящим испытанием, особенно при фильтрации сложных структур данных, которые появляются из-за вариативного состава атрибутов. Тут было испробовано очень много вариантов мапинга и способов построения запросов, но идеального до сих пор не нашли.</p> </li> <li> <p>Для решения проблемы с популяционными запросами придётся делать срезы данных. На данный момент сделано несколько таких “ускорителей” и, к сожалению, не только на уровне Elasticsearch. С одной стороны, они работают, с другой, это снижает общую <a href="/blog/2025/availability/">доступность</a> сервиса поиска, ведь он становится зависим не только от Elasticsearch.</p> </li> <li> <p>Дороговизна решения на базе Elasticsearch — это отдельный пункт. Медицинские данные — это не каталог товаров — сегодня одни, завтра другие. Это данные, которые нужно хранить десятилетиями. Даже текущие потребности в ресурсах, к сожалению, не внушают оптимизма в перспективности использования этой базы. Даже существующее решение на базе SQL-хранилища требует меньших ресурсов, работая не менее производительно.</p> </li> </ul> <h2 id="анализ-условий">Анализ условий</h2> <p>Сделаем декомпозицию и анализ исходных условий. Большая часть анализа сконцентрирована на проработке требований к хранилищу данных, организации хранения и методам поиска.</p> <p>Прежде всего нужно выделить основные архитектурные свойства сервиса поиска:</p> <ul> <li> <em>Доступность.</em> Поиск медицинских данных — это ключевая часть медицинской системы. Если она будет недоступна, то многие сценарии работы будут парализованы. Хранилище, которое будет выбрано для организации поискового индекса, должно обладать хорошей доступностью.</li> <li> <em>Производительность.</em> Как следует из условий, производительность поиска важна, но не критична. Тем не менее, рассматриваемая задача решается в первую очередь из-за проблем с производительностью. Особое внимание следует уделить быстродействию выполнения запросов.</li> <li> <em>Масштабируемость и адаптивность.</em> База данных активно растёт, количество пользователей растёт, уровень цифровизации увеличивается. Необходимо, чтобы система могла адаптироваться ко всё растущим потребностям. База данных и используемые подходы к хранению должны соответствовать данному требованию.</li> </ul> <blockquote> <p>Далее часто будет использоваться термин <em>поисковый индекс</em>. Будем считать, что это структуры данных поискового хранилища, которые позволяют осуществлять быстрый поиск. Поисковый индекс может быть реализован по-разному — это может быть одна или несколько таблиц в базе данных, бинарный индекс, префиксный индекс и т.п. Главная его задача — ускорение поиска.</p> </blockquote> <h3 id="общие-требования">Общие требования</h3> <p>Решаемая задача — это не поиск, а <strong>фильтрация данных</strong>. Поиск — достаточно многозначный термин, который предполагает некоторую нечёткость в запросе. Например, “поиск по ключевым словам”, “поиск по фразе”, “поиск по смыслу”. В текущем контексте мы решаем задачу фильтрации данных, которая не допускает вариативности в толковании условий запроса или нечёткости результатов его выполнения.</p> <p>Например, если среди всех документов выбранного пациента есть только 2 осмотра терапевта, а в поисковом запросе указано, что нужно вернуть документы с типом “Осмотр терапевта”, то результатом выполнения такого запроса ожидаемо должен быть набор из этих 2 документов. Соответственно, результат не предполагает, что в ответе вернутся все документы, в которых встречается <em>фраза</em> “Осмотр терапевта” или что-то в этом роде.</p> <p>Таким образом, решение не подразумевает нечёткий поиск, например, полнотекстовый поиск, поиск похожих значений и т.п. Напротив, нужно решить задачу чёткого поиска, фильтрации данных. Следовательно, <strong>выбираемые инструменты должны в первую очередь эффективно решать задачу фильтрации данных</strong>.</p> <h3 id="особенности-запроса">Особенности запроса</h3> <p>По условию фильтр — сложное логическое выражение с произвольной комбинацией операторов <code class="language-plaintext highlighter-rouge">OR</code>/<code class="language-plaintext highlighter-rouge">AND</code>/<code class="language-plaintext highlighter-rouge">NOT</code>. Подобные запросы типичны для <strong>OLAP-хранилищ</strong> и совершенно нетипичны, например, для OLTP и полнотекстовых индексов. Делать аналитические выборки по OLTP, в которой данные хорошо нормализованы, ещё то удовольствие.</p> <p>Возможная вариативность атрибутов в условии фильтрации полностью исключает возможность использования реляционных СУБД, т.к. ни одна реляционная база не выдержит создания огромного количества индексов на каждый искомый атрибут. Без индексов поиск будет работать, но медленно, неэффективно, с большой утилизацией CPU и I/O. Именно этот результат демонстрирует существующее решение на базе SQL-хранилища.</p> <p>С другой стороны, вариативность атрибутов в условии фильтрации — <strong>характерная нагрузка для колоночных баз данных</strong>, например, ClickHouse или Apache Druid. Именно поэтому некоторые OLAP-хранилища — это колоночные базы данных.</p> <p>Например, в ClickHouse атрибуты (колонки) хранятся в отдельных файлах данных, что положительно сказывается на эффективности выполнения запросов. Если в условии фильтрации фигурируют только 2 атрибута, то и считываться с диска будут данные только из 2 файлов. Это значительно эффективней, т.к. считываются именно те данные, которые нужны для поиска. Такой подход существенно отличает колоночные базы от строковых, в которых данные хранятся построчно, и при вычитывании строк вычитывается множество ненужных данных: все колонки строки, а также соседние строки, ведь файлы данных читаются с диска блоками фиксированных размеров. Подобное поведение колоночных баз <strong>существенно снижает нагрузку на I/O</strong>.</p> <p>Дополнительно, колоночное хранение позволяет <strong>существенно сжимать данные</strong> (в среднем до 10-20 раз, в зависимости от вариативности значений в атрибутах), следовательно, <strong>экономить на хранении</strong>. Сжатие данных предполагает не только компрессию, но и удаление повторяющихся значений. Благодаря этому размеры колоночных файлов становятся незначительными, что <strong>приводит к кратному ускорению поиска</strong>, снижая нагрузку на I/O.</p> <p>Наконец, в колоночных базах для каждой колонки может строиться вероятностный индекс (например, Bloom- или <a href="/blog/2025/data-migration-and-hll/">HLL-фильтр</a>). Этот индекс формируется на основе вставляемых данных. Используя его, можно практически моментально узнать, есть ли в файле искомое значение. Это избавляет от бессмысленного сканирования файлов данных, снижая нагрузку на I/O.</p> <p><img src="/assets/img/blog/2025/2025-12-25-search-service-04.png" alt=""></p> <h3 id="особенности-хранения">Особенности хранения</h3> <p>По условию задачи большинство, если не все, поисковые запросы идут без указания периода создания документов, что могло бы ограничивать объем обрабатываемых данных. Без подобной фильтрации поиск неявно предполагает <strong>сканирование всей базы данных за все периоды</strong>. В такой постановке <strong>время поиска будет расти вместе с ростом базы</strong>. Естественно, такое решение недопустимо, время поиска не должно зависеть от размера базы, и нужно найти подход, который ограничит выборку данных даже при отсутствии в пользовательском запросе фильтра по дате создания документов.</p> <p>Для выполнения поставленной задачи напрашивается какое-то разбиение всего множества данных на группы фиксированных размеров (партиции), но так, чтобы при выполнении запросов можно было выбирать не все, а только определённые партиции. Такой подход, как минимум, обеспечит независимость времени поиска от размера базы и, вероятно, благоприятно скажется на скорости поиска. Однако, чтобы понять, как именно сделать партиционирование данных, нужно рассмотреть и принять к сведению нижеследующие факты.</p> <ul> <li>Поток сохраняемых документов условно бесконечный. Количество пациентов ограничено, но есть риск неравномерного распределения данных по разным группам пациентов.</li> <li>Результат поиска должен быть отсортирован по дате создания документов. Разумно, если документы сразу будут храниться в сортированном виде, чтобы не сортировать данные при каждой выборке.</li> </ul> <p>По совокупности напрашивается единственно верный вывод: <strong>документы в основной таблице поискового хранилища должны храниться с партиционированием по времени создания и с предварительной сортировкой по времени создания</strong> (в обратном хронологическом порядке — от новых документов к старым, как требуется по условию).</p> <p>Подобный подход обеспечит <strong>равномерное распределение данных по всем партициям</strong>, что неминуемо ограничит и усреднит максимальное время фильтрации по каждой партиции. Более того, такое распределение может производиться в автоматическом режиме, без необходимости ручной настройки диапазонов (например, при партиционировании по пациентам возник бы вопрос о количестве партиций). Гранулярность партиционирования (по годам, месяцам, неделям и т.п.) концептуально не важна, но будет рассчитана позже.</p> <p><img src="/assets/img/blog/2025/2025-12-25-search-service-05.png" alt=""></p> <p>Партиционирование по дате создания в том числе позволяет решить вопрос с автоматическим ограничением объема обрабатываемых данных. Для каждого пациента нужно хранить сведения, за какие периоды по нему есть документы. Например, в виде <a href="/blog/2025/data-seive/">вспомогательной таблицы</a> “пациент — список дат” или “пациент — минимальная дата — максимальная дата”. Окончательный вид этой таблицы следует определить на этапе реализации. Вспомогательную таблицу можно заполнять во время записи в поисковый индекс, а затем использовать во время поиска в качестве “ускорителя”. Такой подход можно организовать без дополнительного программирования, путём создания материализованного представления (materialized view), которое будет строиться на базе основной таблицы поискового индекса. Сервис поиска будет писать только в основную таблицу, а база данных будет автоматически формировать и обеспечивать консистентное представление вспомогательной таблицы. Материализованные представления поддерживают все известные OLAP-хранилища. В крайнем случае вспомогательную таблицу можно формировать и вручную, в коде приложения.</p> <p><img src="/assets/img/blog/2025/2025-12-25-search-service-06.png" alt=""></p> <h3 id="актуализация-поискового-индекса">Актуализация поискового индекса</h3> <p>Документы могут изменяться, следовательно, поисковый индекс может устаревать, т.е. хранить старые версии документов. В существующем решении на базе SQL-хранилища такого не происходит, т.к. поиск осуществляется по операционным данным (данные сохраняются в те же таблицы, по которым осуществляется поиск). Очевидно, что новое решение должно, во-первых, <strong>минимизировать время индексации</strong> — новые данные должны появляться в индексе как можно быстрей; во-вторых, <strong>удалять из индекса старые версии документов</strong>, чтобы вероятность их появления в результатах поиска была минимальна, и они не занимали место на диске.</p> <p>Для любой БД удаление — это тяжёлая операция. Это вполне объяснимо: хранилища данных проектируются для хранения данных, а не для их удаления. Удалять данные вручную — это вдвойне неблагодарная работа, т.к. механики эффективного удаления данных очень сильно зависят от внутренних особенностей реализации используемого хранилища. Будет отлично, если хранилище поискового индекса предоставляет механизм автоматического удаления старых версий документов. В противном случае нужно будет реализовать механизм асинхронной очистки, а это крайне непростая задача.</p> <p>К сожалению, не все базы данных имеют средства автоматического схлопывания строк. Из известных мне только ClickHouse имеет подобную функциональность, которая реализуется в виде стратегий <a href="https://clickhouse.com/docs/engines/table-engines/mergetree-family/collapsingmergetree" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">CollapsingMergeTree</code></a> и <a href="https://clickhouse.com/docs/ru/engines/table-engines/mergetree-family/versionedcollapsingmergetree" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">VersionedCollapsingMergeTree</code></a>.</p> <h3 id="популяционные-запросы">Популяционные запросы</h3> <p>Популяционный поиск предполагает наличие <strong>витрин данных</strong>. В противном случае любой популяционный поиск по “сырым данным” будет медленным, ведь <strong>время поиска будет зависеть от размера базы</strong>, а это абсолютно неприемлемо.</p> <p>Строить витрины данных или их подобие вручную, в коде приложения, непозволительно дорого и долго. Нужно рассматривать такие решения, которые будут предлагать максимальную адаптивность к новым или существующим популяционным запросам. Это значит, что <strong>используемое хранилище должно предоставлять средства автоматического создания витрин данных</strong> — срезов данных, которые будут ускорять выполнение запросов определённого типа. Самый простой способ организации таких “ускорителей” — это материализованные представления, работающие по принципу, который описан выше, в примере автоматического ограничения выборки при поиске по пациенту.</p> <p>Сначала сервис поиска анализирует запрос и выбирает нужную стратегию поиска. Реализация стратегии знает, какие оптимизации и с помощью каких именно таблиц, можно применить для ускорения входящего запроса.</p> <p><img src="/assets/img/blog/2025/2025-12-25-search-service-07.png" alt=""></p> <h3 id="задержка-индексации">Задержка индексации</h3> <p>Раздельное хранение операционных и аналитических данных решает вопрос быстродействия, но создаёт проблему с запаздыванием данных в поисковом индексе. Сначала метаданные документов будут сохраняться в операционное хранилище, а затем реплицироваться в индексное. В итоге возникает временной зазор, когда документ уже сохранён, но всё ещё недоступен для поиска.</p> <p>Частично эту задержку можно нивелировать быстрой записью, и в связи с этим можно рассмотреть хранилища, адаптированные для такой нагрузки. Но быстрая запись не всегда достаётся бесплатно. Например, в Cassandra и ClickHouse есть фазы слияния файлов данных (compaction/merge), которые создают всплески нагрузки на I/O и, как следствие, замедляют работу базы.</p> <p>На следующем рисунке показана ситуация, когда один пользователь изменил документ, а второй не смог его найти или результаты поиска уже устарели.</p> <p><img src="/assets/img/blog/2025/2025-12-25-search-service-08.png" alt=""></p> <p>Дополнительно нужно проверить, насколько критично подобное нарушение изоляции для существующих сценариев и интеграций. Вполне возможно, что для некоторых случаев придётся добавлять синхронное ожидание окончания индексации.</p> <p>Вообще говоря, трудно найти сценарии, когда только что сохранённая медицинская информация должна понадобится моментально, и неточность поиска в рамках небольшого лага индексации окажет непоправимый вред пациенту. Как отмечалось выше, гораздо важней <em>доступность</em> функции поиска, поэтому нужно пойти на оправданный компромисс и принять стратегическое архитектурное решение отказа от необходимости синхронного ожидания окончания индексации. Сценарии, в которых важно реагировать на изменения документов, должны быть переделаны на асинхронный режим работы с помощью подписки на уведомления об изменениях документов (см. выше).</p> <h3 id="размер-индекса">Размер индекса</h3> <p>Можно сделать примерную оценку размера индекса. Для этого нужно составить таблицу из атрибутов документа, их размера и предполагаемой степени сжатия (в зависимости от характера данных).</p> <p>Например, идентификатор документа имеет тип данных <a href="/blog/2025/selecting-b-tree-and-uuids/">UUID</a>, занимает 16 байт и имеет низкую степень сжатия в районе 1, т.к. <code class="language-plaintext highlighter-rouge">UUID</code> имеет высокую вариативность. Дата создания документа имеет тип данных <code class="language-plaintext highlighter-rouge">DateTime</code>, занимает 8 байт и имеет высокую степень сжатия в районе 5, т.к. документы упорядочены по дате создания.</p> <p>Предполагаемую степень сжатия лучше оценить заранее, выполнив ряд тестов, или посмотреть на аналитические рекомендации к той БД или алгоритму, который собираетесь использовать. Например, в документации ClickHouse можно найти <a href="https://clickhouse.com/docs/data-compression/compression-in-clickhouse" rel="external nofollow noopener" target="_blank">статью</a>, в которой даются примерные оценки сжатия данных.</p> <p>Просуммировав полученные значения, можно получить два показателя: размер сырых данных и предполагаемый размер сжатых данных.</p> <p>Допустим, анализ показал, что сырые данные одного документа будут занимать <code class="language-plaintext highlighter-rouge">1.5 Kb</code>, а сжатые — <code class="language-plaintext highlighter-rouge">0.5 Kb</code>. Умножив эти показатели на общее количество документов (указанное в условии задачи), можно вычислить предполагаемый размер индекса.</p> <ul> <li>Сырые данные: <code class="language-plaintext highlighter-rouge">5000000000 * 1.5 Kb = 6.98 Tb</code> </li> <li>Сжатые данные: <code class="language-plaintext highlighter-rouge">5000000000 * 0.5 Kb = 2.33 Tb</code> </li> </ul> <p>При стабильном приросте 5 млн. документов в день в течение 10 лет в базу будет добавлено еще 18 млрд. документов. Соответственно, легко можно вычислить предполагаемый прирост.</p> <ul> <li>Сырые данные: <code class="language-plaintext highlighter-rouge">+25.15 Tb</code> (итого <code class="language-plaintext highlighter-rouge">32.13 Tb</code>)</li> <li>Сжатые данные: <code class="language-plaintext highlighter-rouge">+8.38 Tb</code> (итого <code class="language-plaintext highlighter-rouge">10.71 Tb</code>)</li> </ul> <p>При факторе репликации x3 получаем следующие значения (учитываются только сжатые данные).</p> <ul> <li>Текущие потребности: <code class="language-plaintext highlighter-rouge">2.33*3 = 6.98 Tb</code> </li> <li>Потребности в перспективе 10 лет: <code class="language-plaintext highlighter-rouge">10.71*3 = 32.13 Tb</code> </li> </ul> <h3 id="масштабирование-хранения">Масштабирование хранения</h3> <p>База данных непрерывно растёт, а сам рост имеет тенденцию к ускорению (за счёт активной цифровизации). Очевидно, что хранилище данных должно предполагать эффективные механизмы горизонтального масштабирования данных. В идеале оно должно быть простым и <strong>адаптивным</strong>, с минимальным вмешательством человека.</p> <p>Вполне возможно, что в будущем понадобится разделение хранилища на <em>горячее</em> и <em>холодное</em>. В холодное хранилище будут перетекать старые данные, т.к. очевидно, что любая медицинская информация со временем утрачивает свою значимость и актуальность. Предложенное выше партиционирование индекса по дате создания документов способствует эффективному решению этой проблемы.</p> <h3 id="контроль-целостности">Контроль целостности</h3> <p>Организация поискового индекса в отдельной базе данных предполагает необходимость начального наполнения этой базы, а также её последующей синхронизации с хранилищем оперативных данных. Учитывая, что существующее решение основано на базе SQL-хранилища, начальное наполнение нового поискового индекса можно сделать с помощью CDC-конвейера (Change Data Capture), выполненного с помощью <a href="https://debezium.io/" rel="external nofollow noopener" target="_blank">Debezium</a>.</p> <p>Как показывает практика, в распределённых системах всё может пойти не так, как задумано, поэтому нужно сразу предусмотреть способы оперативной заливки данных в поисковый индекс, его частичной или полной синхронизации с оперативным хранилищем, а также <strong>метрики обнаружения рассогласования и потери целостности</strong>. Этот контроль нужно производить асинхронно, анализируя результаты поиска.</p> <h2 id="требования-к-хранилищу">Требования к хранилищу</h2> <p>Подводя итоги, можно выделить следующие ключевые требования к хранилищу данных для построения поискового индекса:</p> <ul> <li>специализация на чётком поиске (фильтрации данных);</li> <li>специализация на OLAP с колоночным хранением данных;</li> <li>возможность партиционирования по времени;</li> <li>возможность создания материализованных представлений;</li> <li>возможность автоматического удаления старых версий;</li> <li>минимальная латентность при сохранении;</li> <li>поддержка сжатия данных;</li> <li>возможность горизонтального масштабирования;</li> <li>открытый исходный код;</li> <li>активная поддержка;</li> <li>доступная лицензия;</li> <li>условная бесплатность.</li> </ul> <p>Дополнительные требования, которые относятся к разряду желательных, но не обязательных:</p> <ul> <li>удобный язык запросов (желательно SQL-подобный);</li> <li>наличие опыта использования и поддержки.</li> </ul> <h2 id="выбор-хранилища">Выбор хранилища</h2> <p>По совокупности обстоятельств идеальным кандидатом для выбора является <a href="https://clickhouse.com/" rel="external nofollow noopener" target="_blank">ClickHouse</a>. Он отвечает всем предъявленным требованиям, включая удобный язык запросов (SQL).</p> <blockquote> <p><strong>Интересный факт</strong></p> <p>В рамках конференции HighLoad++ 2025 был доклад <a href="https://highload.ru/moscow/2025/abstracts/16516" rel="external nofollow noopener" target="_blank">“Как мы ускоряли поиск в модели EAV для 13500 атрибутов через ClickHouse”</a> (от МТС/MWS). Решалась схожая задача: у каждого документа большой и вариативный состав атрибутов, по которым производится аналитический поиск. Задача была эффективно решена с использованием ClickHouse и ряда понятных техник, которые также можно взять на вооружение. В рамках секции вопросов-ответов было подмечено, что <a href="https://druid.apache.org/" rel="external nofollow noopener" target="_blank">Apache Druid</a> решает данную задачу не менее эффективно, однако все согласились, что ClickHouse более известная и развитая технология.</p> </blockquote> <h2 id="план-реализации">План реализации</h2> <p>Примерный план реализации нового решения таков.</p> <ul> <li>Согласовать базовый вариант схемы данных поискового индекса.</li> <li>Сделать первоначальное наполнение индекса с помощью CDC-конвейера. При копировании данных важно следить за состоянием БД и инфраструктуры. Возможно, это даст подсказки относительно эффективности схемы данных; добавит понимание относительно задержек при записи.</li> <li>Провести нагрузочное тестирование, используя типовые поисковые запросы. До автоматического тестирования следует провести ручное тестирование выполнения типовых запросов. Как правило, этого вполне достаточно, чтобы найти основные огрехи схемы данных. Когда ручная проверка перестанет давать результаты, можно переходить к настоящему нагрузочному тестированию.</li> <li>Итеративно повторять предыдущие шаги, пока не будут достигнуты желаемые показатели по производительности, нагрузке на CPU, I/O.</li> <li>Последним шагом добавить поддержку нового поиска в код сервиса. При внедрении нового поиска желательно использовать канареечное развертывание с возможностью отката на предыдущий вариант поиска.</li> </ul> <h2 id="послесловие">Послесловие</h2> <p>Посмею напомнить, что это один из возможных вариантов решения задачи. Как и всегда, подобные решения должны проходить многократные стадии тестирования и апробации. Полное решение достаточно сложное, поэтому важно спланировать свою работу таким образом, чтобы как можно раньше убедиться в его перспективности.</p> </div> </article> <br> <br> <div class="card"> <div class="card-body"> <h4 class="card-title">Понравилась статья?</h4> <p class="card-text"> Посмею напомнить, что у меня есть Telegram-канал <a href="https://t.me/arch_and_dev/79" rel="external nofollow noopener" target="_blank">Архитектоника в ИТ</a>, где я публикую материал на похожие темы примерно раз в неделю. Подписчики меня мотивируют, но ещё больше мотивируют живые дискуссии, ведь именно в них рождается истина. Поэтому подписывайтесь на канал и будем оставаться на связи! ;-) </p> <p class="card-text">Статьи из той же категории:</p> <ul class="list-disc pl-8"> <li class="my-2"> <p class="card-text"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/oom-killer/">OOM Killer к нам приходит</a> </p> </li> <li class="my-2"> <p class="card-text"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/throttling-and-cpu-usage/">Throttling - бесполезная трата CPU</a> </p> </li> <li class="my-2"> <p class="card-text"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2025-year-summary/">Итоги 2025 года</a> </p> </li> <li class="my-2"> <p class="card-text"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ontico-conf-transformation/">Трансформация конференций</a> </p> </li> <li class="my-2"> <p class="card-text"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/9-fallacies-distributed-computing/">9 архитектурных заблуждений о распределённых системах</a> </p> </li> </ul> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Александр Межов. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Напечатайте что-нибудь для поиска"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>