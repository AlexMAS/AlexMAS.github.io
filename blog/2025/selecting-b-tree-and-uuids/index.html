<!DOCTYPE html> <html lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Выбор UUID для первичного ключа таблицы | Александр Межов </title> <meta name="author" content="Александр Межов"> <meta name="description" content="В базах данных, где в качестве алгоритма хранения первичного ключа используется B-tree, отдается предпочтение целочисленным типам данных. Это связано с рядом причин, включая производительность. Но что, если в качестве ключа нужно использовать UUID? Насколько сильно это повлияет на производительность? А можно ли сделать так, чтобы это влияние было сведено к минимуму?"> <meta name="keywords" content="architecture, development, blog, Mezhov, Межов"> <meta property="og:site_name" content="Александр Межов"> <meta property="og:type" content="article"> <meta property="og:title" content="Выбор UUID для первичного ключа таблицы"> <meta property="og:url" content="https://alexmas.github.io//blog/2025/selecting-b-tree-and-uuids/"> <meta property="og:description" content="В базах данных, где в качестве алгоритма хранения первичного ключа используется B-tree, отдается предпочтение целочисленным типам данных. Это связано с рядом причин, включая производительность. Но что, если в качестве ключа нужно использовать UUID? Насколько сильно это повлияет на производительность? А можно ли сделать так, чтобы это влияние было сведено к минимуму?"> <meta property="og:image" content="https://alexmas.github.io//assets/img/blog/2025/2025-03-20-b-tree-and-uuids.png"> <meta property="og:locale" content="ru"> <meta name="twitter:card" content="summary"> <meta name="twitter:title" content="Выбор UUID для первичного ключа таблицы"> <meta name="twitter:description" content="В базах данных, где в качестве алгоритма хранения первичного ключа используется B-tree, отдается предпочтение целочисленным типам данных. Это связано с рядом причин, включая производительность. Но что, если в качестве ключа нужно использовать UUID? Насколько сильно это повлияет на производительность? А можно ли сделать так, чтобы это влияние было сведено к минимуму?"> <meta name="twitter:image" content="https://alexmas.github.io//assets/img/blog/2025/2025-03-20-b-tree-and-uuids.png"> <script type="application/ld+json">
    {
        "author":
        {
            "@type": "Person",
            "name": "Александр Межов"
        },
        "url": "https://alexmas.github.io//blog/2025/selecting-b-tree-and-uuids/",
        "@type": "BlogPosting",
        "description": "В базах данных, где в качестве алгоритма хранения первичного ключа используется B-tree, отдается предпочтение целочисленным типам данных. Это связано с рядом причин, включая производительность. Но что, если в качестве ключа нужно использовать UUID? Насколько сильно это повлияет на производительность? А можно ли сделать так, чтобы это влияние было сведено к минимуму?",
        "headline": "Выбор UUID для первичного ключа таблицы",
        
        "sameAs": "https://t.me/arch_and_dev",
        
        "name": "Александр Межов",
        "@context": "https://schema.org"
    }
  </script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?27787be15f1341be1c13406838f8df52"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://alexmas.github.io//blog/2025/selecting-b-tree-and-uuids/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Александр</span> Межов </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">Обо мне </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Архитектоника в ИТ </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Публикации и выступления </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Выбор UUID для первичного ключа таблицы</h1> <p class="post-meta"> </p> <p class="post-tags"> <a href="/blog/2025"><i class="fa-solid fa-calendar fa-sm"></i> 2025</a>-03-20   ·   <a href="/blog/tag/db"> <i class="fa-solid fa-hashtag fa-sm"></i> db</a>   <a href="/blog/tag/dev"> <i class="fa-solid fa-hashtag fa-sm"></i> dev</a>   ·   <a href="/blog/category/article"> <i class="fa-solid fa-tag fa-sm"></i> article</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>В базах данных, где в качестве алгоритма хранения первичного ключа используется <a href="https://ru.wikipedia.org/wiki/B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE" rel="external nofollow noopener" target="_blank">B-tree</a>, отдается предпочтение целочисленным типам данных. Это связано с рядом причин, включая производительность. Но что, если в качестве ключа нужно использовать <a href="https://ru.wikipedia.org/wiki/UUID" rel="external nofollow noopener" target="_blank">UUID</a>? Насколько сильно это повлияет на производительность? А можно ли сделать так, чтобы это влияние было сведено к минимуму?</p> <p><img src="/assets/img/blog/2025/2025-03-20-b-tree-and-uuids.png" alt=""></p> <h2 id="хранение-индекса-b-tree-на-диске">Хранение индекса B-tree на диске</h2> <p>Для начала нужно рассмотреть корень проблемы — особенности хранения индекса B-tree на диске. Файл индекса B-tree разбивается на блоки фиксированных размеров - страницы. Размер блока обычно принимается 4Кб (или 8Кб в зависимости от файловой системы). Благодаря этому чтение и запись страницы происходит <em>атомарно</em>, за одно обращение к файловой системе.</p> <p>Каждая страница идентифицируется уникальным адресом и ассоциирована с некоторым <em>упорядоченным диапазоном ключей</em>. Физически страница представляет собой упорядоченный набор пар “начало диапазона - ссылка на страницу значений”. Таким образом, страницы организуются в виде дерева, в котором в направлении от “корня” к “листьям” происходит сужение диапазонов. В итоге листовые страницы дерева в зависимости от реализации хранят либо значения, либо прямые ссылки на них.</p> <p><img src="/assets/img/blog/2025/2025-03-20-b-tree-pages.png" alt=""></p> <p>Чтобы найти значение по ключу нужно двигаться от корня, перебирая страницы, диапазоны которых содержат искомый ключ. Такой поиск делается как при чтении, так и при записи значения.</p> <p>Такая модель хранения накладывает ограничения, которые могут негативно сказаться на пропускной способности операций записи:</p> <ol> <li>При добавлении или изменении значения листовая страница переписывается полностью. Это делает невозможным или существенно усложняет конкурентный доступ на запись для ключей, значения которых расположены на одной странице. Можно считать, что на время выполнения записи доступ к странице заблокирован.</li> <li>Если страница не может вместить значение для нового ключа, она распадается на две, а соответствующая родительская страница обновляется с учётом такого разбиения. Можно считать, что на время выполнения записи доступ к родительской и ее дочерним страницам заблокирован.</li> </ol> <p>С одной стороны, алгоритм гарантирует, что дерево остаётся сбалансированным и его глубина для <code class="language-plaintext highlighter-rouge">N</code> ключей никогда не превысит <code class="language-plaintext highlighter-rouge">log(N)</code>, что в совокупности обеспечивает быстроту поиска. С другой стороны, при интенсивной записи пропускная способность напрямую зависит от ключа. Если каждая следующая операция добавления будет содержать случайный ключ, то очень много времени будет тратиться на создание страниц, они будут разряженными и ссылаться на небольшое количество значений, следовательно, индекс будет занимать больше места на диске.</p> <p>Можно сказать, что <em>добавление ключей в индекс B-tree будет максимально эффективным как в плане производительности, так и в плане размера индекса, если добавляемые ключи постоянно возрастают (или убывают)</em>. Или, выражаясь математическим языком, генератор ключей должен быть <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%BD%D0%BE%D1%82%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F" rel="external nofollow noopener" target="_blank">монотонной функцией</a>. Например, если в качестве первичного ключа таблицы выбрано целое число и каждый следующий ключ получается путем инкрементирования предыдущего на единицу.</p> <h2 id="версии-uuid">Версии UUID</h2> <p>Получается, если первичным ключом является UUID, то проблемы неизбежны? И да, и нет. Во-первых, многое зависит от размера таблицы, интенсивности операций вставки, соотношения между чтением и записью. Во-вторых, чаще всего под UUID понимается UUIDv4 (или GUID в экосистеме Windows), в основе которого лежит генератор случайных чисел, который, естественно, не является монотонной функцией. Однако есть несколько версий UUID, точней, несколько способов его реализации, каждый из которых не лучше и не хуже другого и ориентирован на свой спектр задач.</p> <ul> <li>UUIDv1 - Timestamp (little-endian) &amp; Location-based</li> <li>UUIDv2 - Timestamp (little-endian) &amp; Location &amp; Actor-based</li> <li>UUIDv3 - Hash-based (MD5)</li> <li>UUIDv4 - Random-based</li> <li>UUIDv5 - Hash-based (SHA-1)</li> <li>UUIDv6 - Timestamp (big-endian) &amp; Location-based</li> <li>UUIDv7 - Unix-time &amp; Random-based</li> </ul> <p>Более подробную информацию о версиях и форматах UUID легко можно найти в сети. <em>Наибольший интерес представляют версии UUIDv1, v6 и v7</em>, т.к. они основаны на времени, а время, как известно, растет монотонно. (Версия UUIDv2 не рассматривается, т.к. является сложным и специфичным вариантом v1 и мало где поддерживается.)</p> <p>Чтобы понять, как именно ведут себя UUID разных версий, представим их значения в виде больших целых чисел и нарисуем график зависимостей: по горизонтали — порядковый номер генерации, по вертикали — целочисленное представление UUID. Ниже приведены графики из 1000 UUID-ов каждой версии, генерация которых шла в течении 3 часов.</p> <p><img src="/assets/img/blog/2025/2025-03-20-uuid-functions.png" alt=""></p> <p>Как видно, UUIDv1 какое-то время монотонно растет, после чего происходит падение и цикл повторяется вновь. Продолжительность цикла составляет примерно 7.2 минуты, следовательно, каждые 7.2 минуты будет наблюдаться небольшое снижение производительности при вставке новых ключей (во всяком случае, теоретически). Так происходит из-за того, что в формате UUIDv1 время закодировано с обратным порядком байт — от младшего разряда к старшему. Поскольку младшие разряды меняются быстрей старших, появляется “цикличность”, которая и наблюдается на графике.</p> <h2 id="тестирование-uuid">Тестирование UUID</h2> <p>Итак, мы выяснили, что <em>теоретически</em> UUIDv1, v6 и v7 должны работать лучше “привычного” UUIDv4, который основан на генераторе случайных чисел. Да, UUIDv1 имеет некоторые особенности, но насколько они будут критичны на практике, пока не очень понятно. Также непонятно, насколько эти версии UUID уступают по производительности целым числам.</p> <p>Чтобы разобраться с этим, я сделал небольшое “домашнее” тестирование, взяв за основу PostgreSQL 14 и таблицу в формате “ключ-значение”. В качестве ключа — предопределенная версия UUID, в качестве значения — массив байт фиксированного размера (1Кб). Фиксированная размерность значения выбрана специально, чтобы она не оказывала влияния во время тестирования. Тест состоит из двух этапов:</p> <ol> <li>Вставка данных</li> <li>Выборка данных по <em>случайному</em> ключу</li> </ol> <p>Показатели, которые собираемся наблюдать:</p> <ul> <li>Размер индекса на диске</li> <li>Чтение с диска во время вставки данных</li> <li>Время вставки данных</li> <li>Чтение с диска при выборке данных по ключу</li> <li>Время выборки данных по ключу</li> </ul> <blockquote> <p>Выбрана достаточно примитивная и обобщенная модель тестирования. По этой причине я намеренно не буду приводить каких-то абсолютных цифр и конфигурацию оборудования. Моя цель — получить относительные величины и сделать небольшие выводы. Не исключаю, что у вас могут быть получены иные результаты. На практике необходимо производить тестирование, приближенное к реальным условиям.</p> </blockquote> <p>Код теста можно посмотреть на <a href="https://github.com/AlexMAS/postgresql-uuid-test" rel="external nofollow noopener" target="_blank">GitHub</a>.</p> <p><img src="/assets/img/blog/2025/2025-03-20-index-size.png" alt=""> Интерпретация. Во-первых, UUID по размеру в два раза больше <code class="language-plaintext highlighter-rouge">bigserial</code>; во-вторых, случайный характер UUID делает индекс более “разряженным”, изначально у него будет много полупустых страниц. Между тем, <em>чем больше будет таблица, тем менее заметна будет разница, т.к. со временем все страницы индекса все равно будут заполняться.</em> Индекс на основе <code class="language-plaintext highlighter-rouge">bigserial</code> сразу создает “плотный” индекс с минимальным количеством страниц, но это может негативно сказаться на времени записи (см. далее). Обратите внимание, что индексы на основе UUIDv1 и UUIDv6 также достаточно “плотные”.</p> <p><img src="/assets/img/blog/2025/2025-03-20-insert-disk-reads.png" alt=""> Интерпретация. Индекс на основе <code class="language-plaintext highlighter-rouge">bigserial</code> создает минимум страниц, их количество увеличивается линейно. Случайный характер UUID провоцирует быстрый рост числа страниц, следовательно, при вставке данных будет задействовано больше страниц, чтобы найти нужную для записи, следовательно, больше чтений с диска. Здесь UUIDv1 опять в лидерах и, скорей всего, по причине того, что обеспечивает минимум страниц в индексе (см. предыдущий график).</p> <p><img src="/assets/img/blog/2025/2025-03-20-insert-time.png" alt=""> Интерпретация. Плотный индекс значит наличие конфликтов при вставке данных, т.к. две записи в одну и ту же страницу индекса будут выполняться последовательно. <em>Индексы на основе UUID минимизируют конфликты при вставке</em>, ведь данные разбрасываются по разным страницам, следовательно, запись в них может производиться параллельно.</p> <p><img src="/assets/img/blog/2025/2025-03-20-select-disk-reads.png" alt=""> Интерпретация. При чтении случайных ключей считываются случайные страницы индекса. Если предположить, что в реализации базы данных есть какой-то страничный кэш, то толку от него не будет и, скорей всего, он будет только мешать. Возможно, это и повлияло на результат, т.к. как <code class="language-plaintext highlighter-rouge">bigserial</code>, так и UUIDv1 обеспечивают “плотность” индекса, соответственно, больше и чаще бесполезного кэширования страниц. (Однако здесь я затрудняюсь комментировать результат однозначно.)</p> <p><img src="/assets/img/blog/2025/2025-03-20-select-time.png" alt=""> Интерпретация. Полагаю причина аналогична предыдущей ситуации. Больше чтений с диска — больше время выборки.</p> <p>В целом, несмотря на наивность проведенного тестирования, полученные результаты вполне объяснимы, что вселяет уверенность в их правдоподобность. Осталось построить сводную таблицу по показателям. Для оценки показателей используем простейшую схему: 3 балла — за лучший результат, 2 — за средний, 1 — за худший.</p> <p><img src="/assets/img/blog/2025/2025-03-20-total-score.png" alt=""></p> <p>По совокупности факторов наилучший результат показал UUIDv1 (неожиданно), а наихудший — UUIDv4 (ожидаемо). Целочисленный идентификатор работает не сильно лучше UUIDv6 и UUIDv7.</p> <h2 id="небольшие-выводы">Небольшие выводы</h2> <p>В качестве вывода позволю себе дать несколько советов.</p> <ul> <li>Ответьте на вопрос, насколько для вас существенна разница (целое число или UUID). В большинстве случаев вопрос выбора не столь критичен, т.к. размеры таблицы невелики, как и интенсивность вставки/выборки данных.</li> <li>Проводите тестирование, приближенное к реальным условиям. На результат влияет окружение, версия базы данных, модель данных, характер нагрузки и т.п. В теоретических статьях, подобных этой, может не учитываться ваша специфика.</li> <li>При оценке ранжируйте показатели в соответствии с их важностью. В приведенном примере были выбраны лишь некоторые показатели из возможных, а при подведении итогов все они рассматривались как равнозначные. Вполне возможно, что для кого-то размер индекса на диске более критичен, чем время выборки данных по ключу; для кого-то важно время вставки данных.</li> <li>Если хотите компактность индекса, используйте целые числа или UUIDv1. Если хотите быструю запись и быстрое чтение, используйте UUIDv1. Между тем, с осторожностью относитесь к подобным утверждениям и проверяйте их на практике. :)</li> </ul> </div> </article> <br> <br> <div class="card"> <div class="card-body"> <h4 class="card-title">Понравилась статья?</h4> <p class="card-text"> Посмею напомнить, что у меня есть Telegram-канал <a href="https://t.me/arch_and_dev/79" rel="external nofollow noopener" target="_blank">Архитектоника в ИТ</a>, где я публикую материал на похожие темы примерно раз в неделю. Подписчики меня мотивируют, но ещё больше мотивируют живые дискуссии, ведь именно в них рождается истина. Поэтому подписывайтесь на канал и будем оставаться на связи! ;-) </p> <p class="card-text">Статьи из той же категории:</p> <ul class="list-disc pl-8"> <li class="my-2"> <p class="card-text"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/throttling-and-cpu-usage/">Throttling - бесполезная трата CPU</a> </p> </li> <li class="my-2"> <p class="card-text"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2025-year-summary/">Итоги 2025 года</a> </p> </li> <li class="my-2"> <p class="card-text"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/search-for-medical-documents/">Первичный анализ задачи поиска медицинских документов</a> </p> </li> <li class="my-2"> <p class="card-text"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ontico-conf-transformation/">Трансформация конференций</a> </p> </li> <li class="my-2"> <p class="card-text"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/9-fallacies-distributed-computing/">9 архитектурных заблуждений о распределённых системах</a> </p> </li> </ul> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Александр Межов. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Напечатайте что-нибудь для поиска"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>